(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/react-grid-layout/dist/chunk-AWM66AWF.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bottom",
    ()=>bottom,
    "calcGridCellDimensions",
    ()=>calcGridCellDimensions,
    "calcGridColWidth",
    ()=>calcGridColWidth,
    "calcGridItemPosition",
    ()=>calcGridItemPosition,
    "calcGridItemWHPx",
    ()=>calcGridItemWHPx,
    "calcWH",
    ()=>calcWH,
    "calcWHRaw",
    ()=>calcWHRaw,
    "calcXY",
    ()=>calcXY,
    "calcXYRaw",
    ()=>calcXYRaw,
    "clamp",
    ()=>clamp,
    "cloneLayout",
    ()=>cloneLayout,
    "cloneLayoutItem",
    ()=>cloneLayoutItem,
    "collides",
    ()=>collides,
    "correctBounds",
    ()=>correctBounds,
    "getAllCollisions",
    ()=>getAllCollisions,
    "getFirstCollision",
    ()=>getFirstCollision,
    "getLayoutItem",
    ()=>getLayoutItem,
    "getStatics",
    ()=>getStatics,
    "modifyLayout",
    ()=>modifyLayout,
    "moveElement",
    ()=>moveElement,
    "moveElementAwayFromCollision",
    ()=>moveElementAwayFromCollision,
    "sortLayoutItems",
    ()=>sortLayoutItems,
    "sortLayoutItemsByColRow",
    ()=>sortLayoutItemsByColRow,
    "sortLayoutItemsByRowCol",
    ()=>sortLayoutItemsByRowCol,
    "validateLayout",
    ()=>validateLayout,
    "withLayoutItem",
    ()=>withLayoutItem
]);
// src/core/calculate.ts
function calcGridColWidth(positionParams) {
    const { margin, containerPadding, containerWidth, cols } = positionParams;
    return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;
}
function calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {
    if (!Number.isFinite(gridUnits)) return gridUnits;
    return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);
}
function calcGridItemPosition(positionParams, x, y, w, h, dragPosition, resizePosition) {
    const { margin, containerPadding, rowHeight } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    let width;
    let height;
    let top;
    let left;
    if (resizePosition) {
        width = Math.round(resizePosition.width);
        height = Math.round(resizePosition.height);
    } else {
        width = calcGridItemWHPx(w, colWidth, margin[0]);
        height = calcGridItemWHPx(h, rowHeight, margin[1]);
    }
    if (dragPosition) {
        top = Math.round(dragPosition.top);
        left = Math.round(dragPosition.left);
    } else if (resizePosition) {
        top = Math.round(resizePosition.top);
        left = Math.round(resizePosition.left);
    } else {
        top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);
        left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);
    }
    if (!dragPosition && !resizePosition) {
        if (Number.isFinite(w)) {
            const siblingLeft = Math.round((colWidth + margin[0]) * (x + w) + containerPadding[0]);
            const actualMarginRight = siblingLeft - left - width;
            if (actualMarginRight !== margin[0]) {
                width += actualMarginRight - margin[0];
            }
        }
        if (Number.isFinite(h)) {
            const siblingTop = Math.round((rowHeight + margin[1]) * (y + h) + containerPadding[1]);
            const actualMarginBottom = siblingTop - top - height;
            if (actualMarginBottom !== margin[1]) {
                height += actualMarginBottom - margin[1];
            }
        }
    }
    return {
        top,
        left,
        width,
        height
    };
}
function calcXY(positionParams, top, left, w, h) {
    const { margin, containerPadding, cols, rowHeight, maxRows } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));
    let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));
    x = clamp(x, 0, cols - w);
    y = clamp(y, 0, maxRows - h);
    return {
        x,
        y
    };
}
function calcXYRaw(positionParams, top, left) {
    const { margin, containerPadding, rowHeight } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    const x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));
    const y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));
    return {
        x,
        y
    };
}
function calcWH(positionParams, width, height, x, y, handle) {
    const { margin, maxRows, cols, rowHeight } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    const w = Math.round((width + margin[0]) / (colWidth + margin[0]));
    const h = Math.round((height + margin[1]) / (rowHeight + margin[1]));
    let _w = clamp(w, 0, cols - x);
    let _h = clamp(h, 0, maxRows - y);
    if (handle === "sw" || handle === "w" || handle === "nw") {
        _w = clamp(w, 0, cols);
    }
    if (handle === "nw" || handle === "n" || handle === "ne") {
        _h = clamp(h, 0, maxRows);
    }
    return {
        w: _w,
        h: _h
    };
}
function calcWHRaw(positionParams, width, height) {
    const { margin, rowHeight } = positionParams;
    const colWidth = calcGridColWidth(positionParams);
    const w = Math.max(1, Math.round((width + margin[0]) / (colWidth + margin[0])));
    const h = Math.max(1, Math.round((height + margin[1]) / (rowHeight + margin[1])));
    return {
        w,
        h
    };
}
function clamp(num, lowerBound, upperBound) {
    return Math.max(Math.min(num, upperBound), lowerBound);
}
function calcGridCellDimensions(config) {
    const { width, cols, rowHeight, margin = [
        10,
        10
    ], containerPadding } = config;
    const padding = containerPadding ?? margin;
    const cellWidth = (width - padding[0] * 2 - margin[0] * (cols - 1)) / cols;
    const cellHeight = rowHeight;
    return {
        cellWidth,
        cellHeight,
        offsetX: padding[0],
        offsetY: padding[1],
        gapX: margin[0],
        gapY: margin[1],
        cols,
        containerWidth: width
    };
}
// src/core/collision.ts
function collides(l1, l2) {
    if (l1.i === l2.i) return false;
    if (l1.x + l1.w <= l2.x) return false;
    if (l1.x >= l2.x + l2.w) return false;
    if (l1.y + l1.h <= l2.y) return false;
    if (l1.y >= l2.y + l2.h) return false;
    return true;
}
function getFirstCollision(layout, layoutItem) {
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item !== void 0 && collides(item, layoutItem)) {
            return item;
        }
    }
    return void 0;
}
function getAllCollisions(layout, layoutItem) {
    return layout.filter((l)=>collides(l, layoutItem));
}
// src/core/sort.ts
function sortLayoutItems(layout, compactType) {
    if (compactType === "horizontal") {
        return sortLayoutItemsByColRow(layout);
    }
    if (compactType === "vertical") {
        return sortLayoutItemsByRowCol(layout);
    }
    if (compactType === "wrap") {
        return sortLayoutItemsByRowCol(layout);
    }
    return [
        ...layout
    ];
}
function sortLayoutItemsByRowCol(layout) {
    return [
        ...layout
    ].sort((a, b)=>{
        if (a.y !== b.y) {
            return a.y - b.y;
        }
        return a.x - b.x;
    });
}
function sortLayoutItemsByColRow(layout) {
    return [
        ...layout
    ].sort((a, b)=>{
        if (a.x !== b.x) {
            return a.x - b.x;
        }
        return a.y - b.y;
    });
}
// src/core/layout.ts
function bottom(layout) {
    let max = 0;
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item !== void 0) {
            const bottomY = item.y + item.h;
            if (bottomY > max) max = bottomY;
        }
    }
    return max;
}
function getLayoutItem(layout, id) {
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item !== void 0 && item.i === id) {
            return item;
        }
    }
    return void 0;
}
function getStatics(layout) {
    return layout.filter((l)=>l.static === true);
}
function cloneLayoutItem(layoutItem) {
    return {
        i: layoutItem.i,
        x: layoutItem.x,
        y: layoutItem.y,
        w: layoutItem.w,
        h: layoutItem.h,
        minW: layoutItem.minW,
        maxW: layoutItem.maxW,
        minH: layoutItem.minH,
        maxH: layoutItem.maxH,
        moved: Boolean(layoutItem.moved),
        static: Boolean(layoutItem.static),
        isDraggable: layoutItem.isDraggable,
        isResizable: layoutItem.isResizable,
        resizeHandles: layoutItem.resizeHandles,
        constraints: layoutItem.constraints,
        isBounded: layoutItem.isBounded
    };
}
function cloneLayout(layout) {
    const newLayout = new Array(layout.length);
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item !== void 0) {
            newLayout[i] = cloneLayoutItem(item);
        }
    }
    return newLayout;
}
function modifyLayout(layout, layoutItem) {
    const newLayout = new Array(layout.length);
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item !== void 0) {
            if (layoutItem.i === item.i) {
                newLayout[i] = layoutItem;
            } else {
                newLayout[i] = item;
            }
        }
    }
    return newLayout;
}
function withLayoutItem(layout, itemKey, cb) {
    let item = getLayoutItem(layout, itemKey);
    if (!item) {
        return [
            [
                ...layout
            ],
            null
        ];
    }
    item = cb(cloneLayoutItem(item));
    const newLayout = modifyLayout(layout, item);
    return [
        newLayout,
        item
    ];
}
function correctBounds(layout, bounds) {
    const collidesWith = getStatics(layout);
    for(let i = 0; i < layout.length; i++){
        const l = layout[i];
        if (l === void 0) continue;
        if (l.x + l.w > bounds.cols) {
            l.x = bounds.cols - l.w;
        }
        if (l.x < 0) {
            l.x = 0;
            l.w = bounds.cols;
        }
        if (!l.static) {
            collidesWith.push(l);
        } else {
            while(getFirstCollision(collidesWith, l)){
                l.y++;
            }
        }
    }
    return layout;
}
function moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols, allowOverlap) {
    if (l.static && l.isDraggable !== true) {
        return [
            ...layout
        ];
    }
    if (l.y === y && l.x === x) {
        return [
            ...layout
        ];
    }
    const oldX = l.x;
    const oldY = l.y;
    if (typeof x === "number") l.x = x;
    if (typeof y === "number") l.y = y;
    l.moved = true;
    let sorted = sortLayoutItems(layout, compactType);
    const movingUp = compactType === "vertical" && typeof y === "number" ? oldY >= y : compactType === "horizontal" && typeof x === "number" ? oldX >= x : false;
    if (movingUp) {
        sorted = sorted.reverse();
    }
    const collisions = getAllCollisions(sorted, l);
    const hasCollisions = collisions.length > 0;
    if (hasCollisions && allowOverlap) {
        return cloneLayout(layout);
    }
    if (hasCollisions && preventCollision) {
        l.x = oldX;
        l.y = oldY;
        l.moved = false;
        return layout;
    }
    let resultLayout = [
        ...layout
    ];
    for(let i = 0; i < collisions.length; i++){
        const collision = collisions[i];
        if (collision === void 0) continue;
        if (collision.moved) continue;
        if (collision.static) {
            resultLayout = moveElementAwayFromCollision(resultLayout, collision, l, isUserAction, compactType);
        } else {
            resultLayout = moveElementAwayFromCollision(resultLayout, l, collision, isUserAction, compactType);
        }
    }
    return resultLayout;
}
function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {
    const compactH = compactType === "horizontal";
    const compactV = compactType === "vertical";
    const preventCollision = collidesWith.static;
    if (isUserAction) {
        isUserAction = false;
        const fakeItem = {
            x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,
            y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,
            w: itemToMove.w,
            h: itemToMove.h,
            i: "-1"
        };
        const firstCollision = getFirstCollision(layout, fakeItem);
        const collisionNorth = firstCollision !== void 0 && firstCollision.y + firstCollision.h > collidesWith.y;
        const collisionWest = firstCollision !== void 0 && collidesWith.x + collidesWith.w > firstCollision.x;
        if (!firstCollision) {
            return moveElement(layout, itemToMove, compactH ? fakeItem.x : void 0, compactV ? fakeItem.y : void 0, isUserAction, preventCollision, compactType);
        }
        if (collisionNorth && compactV) {
            return moveElement(layout, itemToMove, void 0, itemToMove.y + 1, isUserAction, preventCollision, compactType);
        }
        if (collisionNorth && compactType === null) {
            collidesWith.y = itemToMove.y;
            itemToMove.y = itemToMove.y + itemToMove.h;
            return [
                ...layout
            ];
        }
        if (collisionWest && compactH) {
            return moveElement(layout, collidesWith, itemToMove.x, void 0, isUserAction, preventCollision, compactType);
        }
    }
    const newX = compactH ? itemToMove.x + 1 : void 0;
    const newY = compactV ? itemToMove.y + 1 : void 0;
    if (newX === void 0 && newY === void 0) {
        return [
            ...layout
        ];
    }
    return moveElement(layout, itemToMove, newX, newY, isUserAction, preventCollision, compactType);
}
function validateLayout(layout, contextName = "Layout") {
    const requiredProps = [
        "x",
        "y",
        "w",
        "h"
    ];
    if (!Array.isArray(layout)) {
        throw new Error(`${contextName} must be an array!`);
    }
    for(let i = 0; i < layout.length; i++){
        const item = layout[i];
        if (item === void 0) continue;
        for (const key of requiredProps){
            const value = item[key];
            if (typeof value !== "number" || Number.isNaN(value)) {
                throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${String(value)} (${typeof value})`);
            }
        }
        if (item.i !== void 0 && typeof item.i !== "string") {
            throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${String(item.i)} (${typeof item.i})`);
        }
    }
}
;
 //# sourceMappingURL=chunk-AWM66AWF.mjs.map
 //# sourceMappingURL=chunk-AWM66AWF.mjs.map
}),
"[project]/node_modules/react-grid-layout/dist/chunk-XYPIYYYQ.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "absoluteStrategy",
    ()=>absoluteStrategy,
    "applyPositionConstraints",
    ()=>applyPositionConstraints,
    "applySizeConstraints",
    ()=>applySizeConstraints,
    "aspectRatio",
    ()=>aspectRatio,
    "boundedX",
    ()=>boundedX,
    "boundedY",
    ()=>boundedY,
    "compactItemHorizontal",
    ()=>compactItemHorizontal,
    "compactItemVertical",
    ()=>compactItemVertical,
    "containerBounds",
    ()=>containerBounds,
    "createScaledStrategy",
    ()=>createScaledStrategy,
    "defaultConstraints",
    ()=>defaultConstraints,
    "defaultDragConfig",
    ()=>defaultDragConfig,
    "defaultDropConfig",
    ()=>defaultDropConfig,
    "defaultGridConfig",
    ()=>defaultGridConfig,
    "defaultPositionStrategy",
    ()=>defaultPositionStrategy,
    "defaultResizeConfig",
    ()=>defaultResizeConfig,
    "findOrGenerateResponsiveLayout",
    ()=>findOrGenerateResponsiveLayout,
    "getBreakpointFromWidth",
    ()=>getBreakpointFromWidth,
    "getColsFromBreakpoint",
    ()=>getColsFromBreakpoint,
    "getCompactor",
    ()=>getCompactor,
    "getIndentationValue",
    ()=>getIndentationValue,
    "gridBounds",
    ()=>gridBounds,
    "horizontalCompactor",
    ()=>horizontalCompactor,
    "horizontalOverlapCompactor",
    ()=>horizontalOverlapCompactor,
    "maxSize",
    ()=>maxSize,
    "minMaxSize",
    ()=>minMaxSize,
    "minSize",
    ()=>minSize,
    "noCompactor",
    ()=>noCompactor,
    "noOverlapCompactor",
    ()=>noOverlapCompactor,
    "perc",
    ()=>perc,
    "resizeItemInDirection",
    ()=>resizeItemInDirection,
    "resolveCompactionCollision",
    ()=>resolveCompactionCollision,
    "setTopLeft",
    ()=>setTopLeft,
    "setTransform",
    ()=>setTransform,
    "snapToGrid",
    ()=>snapToGrid,
    "sortBreakpoints",
    ()=>sortBreakpoints,
    "transformStrategy",
    ()=>transformStrategy,
    "verticalCompactor",
    ()=>verticalCompactor,
    "verticalOverlapCompactor",
    ()=>verticalOverlapCompactor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/chunk-AWM66AWF.mjs [app-client] (ecmascript)");
;
// src/core/constraints.ts
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
var gridBounds = {
    name: "gridBounds",
    constrainPosition (item, x, y, { cols, maxRows }) {
        return {
            x: clamp(x, 0, Math.max(0, cols - item.w)),
            y: clamp(y, 0, Math.max(0, maxRows - item.h))
        };
    },
    constrainSize (item, w, h, handle, { cols, maxRows }) {
        const maxW = handle === "w" || handle === "nw" || handle === "sw" ? item.x + item.w : cols - item.x;
        const maxH = handle === "n" || handle === "nw" || handle === "ne" ? item.y + item.h : maxRows - item.y;
        return {
            w: clamp(w, 1, Math.max(1, maxW)),
            h: clamp(h, 1, Math.max(1, maxH))
        };
    }
};
var minMaxSize = {
    name: "minMaxSize",
    constrainSize (item, w, h) {
        return {
            w: clamp(w, item.minW ?? 1, item.maxW ?? Infinity),
            h: clamp(h, item.minH ?? 1, item.maxH ?? Infinity)
        };
    }
};
var containerBounds = {
    name: "containerBounds",
    constrainPosition (item, x, y, { cols, maxRows, containerHeight, rowHeight, margin }) {
        const visibleRows = containerHeight > 0 ? Math.floor((containerHeight + margin[1]) / (rowHeight + margin[1])) : maxRows;
        return {
            x: clamp(x, 0, Math.max(0, cols - item.w)),
            y: clamp(y, 0, Math.max(0, visibleRows - item.h))
        };
    }
};
var boundedX = {
    name: "boundedX",
    constrainPosition (item, x, y, { cols }) {
        return {
            x: clamp(x, 0, Math.max(0, cols - item.w)),
            y
        };
    }
};
var boundedY = {
    name: "boundedY",
    constrainPosition (item, x, y, { maxRows }) {
        return {
            x,
            y: clamp(y, 0, Math.max(0, maxRows - item.h))
        };
    }
};
function aspectRatio(ratio) {
    return {
        name: `aspectRatio(${ratio})`,
        constrainSize (_item, w, _h, _handle, context) {
            const { cols, containerWidth, rowHeight, margin } = context;
            const colWidth = (containerWidth - margin[0] * (cols - 1)) / cols;
            const pixelWidth = colWidth * w + margin[0] * Math.max(0, w - 1);
            const pixelHeight = pixelWidth / ratio;
            const h = Math.max(1, Math.round((pixelHeight + margin[1]) / (rowHeight + margin[1])));
            return {
                w,
                h
            };
        }
    };
}
function snapToGrid(stepX, stepY = stepX) {
    if (stepX <= 0 || stepY <= 0) {
        throw new Error(`snapToGrid: step values must be positive (got stepX=${stepX}, stepY=${stepY})`);
    }
    return {
        name: `snapToGrid(${stepX}, ${stepY})`,
        constrainPosition (_item, x, y) {
            return {
                x: Math.round(x / stepX) * stepX,
                y: Math.round(y / stepY) * stepY
            };
        }
    };
}
function minSize(minW, minH) {
    return {
        name: `minSize(${minW}, ${minH})`,
        constrainSize (_item, w, h) {
            return {
                w: Math.max(minW, w),
                h: Math.max(minH, h)
            };
        }
    };
}
function maxSize(maxW, maxH) {
    return {
        name: `maxSize(${maxW}, ${maxH})`,
        constrainSize (_item, w, h) {
            return {
                w: Math.min(maxW, w),
                h: Math.min(maxH, h)
            };
        }
    };
}
var defaultConstraints = [
    gridBounds,
    minMaxSize
];
function applyPositionConstraints(constraints, item, x, y, context) {
    let result = {
        x,
        y
    };
    for (const constraint of constraints){
        if (constraint.constrainPosition) {
            result = constraint.constrainPosition(item, result.x, result.y, context);
        }
    }
    if (item.constraints) {
        for (const constraint of item.constraints){
            if (constraint.constrainPosition) {
                result = constraint.constrainPosition(item, result.x, result.y, context);
            }
        }
    }
    return result;
}
function applySizeConstraints(constraints, item, w, h, handle, context) {
    let result = {
        w,
        h
    };
    for (const constraint of constraints){
        if (constraint.constrainSize) {
            result = constraint.constrainSize(item, result.w, result.h, handle, context);
        }
    }
    if (item.constraints) {
        for (const constraint of item.constraints){
            if (constraint.constrainSize) {
                result = constraint.constrainSize(item, result.w, result.h, handle, context);
            }
        }
    }
    return result;
}
// src/core/position.ts
function setTransform({ top, left, width, height }) {
    const translate = `translate(${left}px,${top}px)`;
    return {
        transform: translate,
        WebkitTransform: translate,
        MozTransform: translate,
        msTransform: translate,
        OTransform: translate,
        width: `${width}px`,
        height: `${height}px`,
        position: "absolute"
    };
}
function setTopLeft({ top, left, width, height }) {
    return {
        top: `${top}px`,
        left: `${left}px`,
        width: `${width}px`,
        height: `${height}px`,
        position: "absolute"
    };
}
function perc(num) {
    return num * 100 + "%";
}
function constrainWidth(left, currentWidth, newWidth, containerWidth) {
    return left + newWidth > containerWidth ? currentWidth : newWidth;
}
function constrainHeight(top, currentHeight, newHeight) {
    return top < 0 ? currentHeight : newHeight;
}
function constrainLeft(left) {
    return Math.max(0, left);
}
function constrainTop(top) {
    return Math.max(0, top);
}
var resizeNorth = (currentSize, newSize, _containerWidth)=>{
    const { left, height, width } = newSize;
    const top = currentSize.top - (height - currentSize.height);
    return {
        left,
        width,
        height: constrainHeight(top, currentSize.height, height),
        top: constrainTop(top)
    };
};
var resizeEast = (currentSize, newSize, containerWidth)=>{
    const { top, left, height, width } = newSize;
    return {
        top,
        height,
        width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),
        left: constrainLeft(left)
    };
};
var resizeWest = (currentSize, newSize, _containerWidth)=>{
    const { top, height, width } = newSize;
    const left = currentSize.left + currentSize.width - width;
    if (left < 0) {
        return {
            height,
            width: currentSize.left + currentSize.width,
            top: constrainTop(top),
            left: 0
        };
    }
    return {
        height,
        width,
        top: constrainTop(top),
        left
    };
};
var resizeSouth = (currentSize, newSize, _containerWidth)=>{
    const { top, left, height, width } = newSize;
    return {
        width,
        left,
        height: constrainHeight(top, currentSize.height, height),
        top: constrainTop(top)
    };
};
var resizeNorthEast = (currentSize, newSize, containerWidth)=>resizeNorth(currentSize, resizeEast(currentSize, newSize, containerWidth));
var resizeNorthWest = (currentSize, newSize, containerWidth)=>resizeNorth(currentSize, resizeWest(currentSize, newSize));
var resizeSouthEast = (currentSize, newSize, containerWidth)=>resizeSouth(currentSize, resizeEast(currentSize, newSize, containerWidth));
var resizeSouthWest = (currentSize, newSize, containerWidth)=>resizeSouth(currentSize, resizeWest(currentSize, newSize));
var resizeHandlerMap = {
    n: resizeNorth,
    ne: resizeNorthEast,
    e: resizeEast,
    se: resizeSouthEast,
    s: resizeSouth,
    sw: resizeSouthWest,
    w: resizeWest,
    nw: resizeNorthWest
};
function resizeItemInDirection(direction, currentSize, newSize, containerWidth) {
    const handler = resizeHandlerMap[direction];
    if (!handler) {
        return newSize;
    }
    return handler(currentSize, {
        ...currentSize,
        ...newSize
    }, containerWidth);
}
var transformStrategy = {
    type: "transform",
    scale: 1,
    calcStyle (pos) {
        return setTransform(pos);
    }
};
var absoluteStrategy = {
    type: "absolute",
    scale: 1,
    calcStyle (pos) {
        return setTopLeft(pos);
    }
};
function createScaledStrategy(scale) {
    return {
        type: "transform",
        scale,
        calcStyle (pos) {
            return setTransform(pos);
        },
        calcDragPosition (clientX, clientY, offsetX, offsetY) {
            return {
                left: (clientX - offsetX) / scale,
                top: (clientY - offsetY) / scale
            };
        }
    };
}
var defaultPositionStrategy = transformStrategy;
// src/core/types.ts
var defaultGridConfig = {
    cols: 12,
    rowHeight: 150,
    margin: [
        10,
        10
    ],
    containerPadding: null,
    maxRows: Infinity
};
var defaultDragConfig = {
    enabled: true,
    bounded: false,
    threshold: 3
};
var defaultResizeConfig = {
    enabled: true,
    handles: [
        "se"
    ]
};
var defaultDropConfig = {
    enabled: false,
    defaultItem: {
        w: 1,
        h: 1
    }
};
// src/core/compactors.ts
function resolveCompactionCollision(layout, item, moveToCoord, axis, hasStatics) {
    const sizeProp = axis === "x" ? "w" : "h";
    item[axis] += 1;
    const itemIndex = layout.findIndex((l)=>l.i === item.i);
    const layoutHasStatics = hasStatics ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStatics"])(layout).length > 0;
    for(let i = itemIndex + 1; i < layout.length; i++){
        const otherItem = layout[i];
        if (otherItem === void 0) continue;
        if (otherItem.static) continue;
        if (!layoutHasStatics && otherItem.y > item.y + item.h) break;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collides"])(item, otherItem)) {
            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis, layoutHasStatics);
        }
    }
    item[axis] = moveToCoord;
}
function compactItemVertical(compareWith, l, fullLayout, maxY) {
    l.x = Math.max(l.x, 0);
    l.y = Math.max(l.y, 0);
    l.y = Math.min(maxY, l.y);
    while(l.y > 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstCollision"])(compareWith, l)){
        l.y--;
    }
    let collision;
    while((collision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstCollision"])(compareWith, l)) !== void 0){
        resolveCompactionCollision(fullLayout, l, collision.y + collision.h, "y");
    }
    l.y = Math.max(l.y, 0);
    return l;
}
function compactItemHorizontal(compareWith, l, cols, fullLayout) {
    l.x = Math.max(l.x, 0);
    l.y = Math.max(l.y, 0);
    while(l.x > 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstCollision"])(compareWith, l)){
        l.x--;
    }
    let collision;
    while((collision = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstCollision"])(compareWith, l)) !== void 0){
        resolveCompactionCollision(fullLayout, l, collision.x + collision.w, "x");
        if (l.x + l.w > cols) {
            l.x = cols - l.w;
            l.y++;
            while(l.x > 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstCollision"])(compareWith, l)){
                l.x--;
            }
        }
    }
    l.x = Math.max(l.x, 0);
    return l;
}
var verticalCompactor = {
    type: "vertical",
    allowOverlap: false,
    compact (layout, _cols) {
        const compareWith = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStatics"])(layout);
        let maxY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bottom"])(compareWith);
        const sorted = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortLayoutItemsByRowCol"])(layout);
        const out = new Array(layout.length);
        for(let i = 0; i < sorted.length; i++){
            const sortedItem = sorted[i];
            if (sortedItem === void 0) continue;
            let l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayoutItem"])(sortedItem);
            if (!l.static) {
                l = compactItemVertical(compareWith, l, sorted, maxY);
                maxY = Math.max(maxY, l.y + l.h);
                compareWith.push(l);
            }
            const originalIndex = layout.indexOf(sortedItem);
            out[originalIndex] = l;
            l.moved = false;
        }
        return out;
    }
};
var horizontalCompactor = {
    type: "horizontal",
    allowOverlap: false,
    compact (layout, cols) {
        const compareWith = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStatics"])(layout);
        const sorted = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortLayoutItemsByColRow"])(layout);
        const out = new Array(layout.length);
        for(let i = 0; i < sorted.length; i++){
            const sortedItem = sorted[i];
            if (sortedItem === void 0) continue;
            let l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayoutItem"])(sortedItem);
            if (!l.static) {
                l = compactItemHorizontal(compareWith, l, cols, sorted);
                compareWith.push(l);
            }
            const originalIndex = layout.indexOf(sortedItem);
            out[originalIndex] = l;
            l.moved = false;
        }
        return out;
    }
};
var noCompactor = {
    type: null,
    allowOverlap: false,
    compact (layout, _cols) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(layout);
    }
};
var verticalOverlapCompactor = {
    ...verticalCompactor,
    allowOverlap: true,
    compact (layout, _cols) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(layout);
    }
};
var horizontalOverlapCompactor = {
    ...horizontalCompactor,
    allowOverlap: true,
    compact (layout, _cols) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(layout);
    }
};
var noOverlapCompactor = {
    ...noCompactor,
    allowOverlap: true
};
function getCompactor(compactType, allowOverlap = false, preventCollision = false) {
    let baseCompactor;
    if (allowOverlap) {
        if (compactType === "vertical") baseCompactor = verticalOverlapCompactor;
        else if (compactType === "horizontal") baseCompactor = horizontalOverlapCompactor;
        else baseCompactor = noOverlapCompactor;
    } else {
        if (compactType === "vertical") baseCompactor = verticalCompactor;
        else if (compactType === "horizontal") baseCompactor = horizontalCompactor;
        else baseCompactor = noCompactor;
    }
    if (preventCollision) {
        return {
            ...baseCompactor,
            preventCollision
        };
    }
    return baseCompactor;
}
// src/core/responsive.ts
function sortBreakpoints(breakpoints) {
    const keys = Object.keys(breakpoints);
    return keys.sort((a, b)=>breakpoints[a] - breakpoints[b]);
}
function getBreakpointFromWidth(breakpoints, width) {
    const sorted = sortBreakpoints(breakpoints);
    let matching = sorted[0];
    if (matching === void 0) {
        throw new Error("No breakpoints defined");
    }
    for(let i = 1; i < sorted.length; i++){
        const breakpointName = sorted[i];
        if (breakpointName === void 0) continue;
        const breakpointWidth = breakpoints[breakpointName];
        if (width > breakpointWidth) {
            matching = breakpointName;
        }
    }
    return matching;
}
function getColsFromBreakpoint(breakpoint, cols) {
    const colCount = cols[breakpoint];
    if (colCount === void 0) {
        throw new Error(`ResponsiveReactGridLayout: \`cols\` entry for breakpoint ${String(breakpoint)} is missing!`);
    }
    return colCount;
}
function findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactTypeOrCompactor) {
    const existingLayout = layouts[breakpoint];
    if (existingLayout) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(existingLayout);
    }
    let layout = layouts[lastBreakpoint];
    const breakpointsSorted = sortBreakpoints(breakpoints);
    const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
    for(let i = 0; i < breakpointsAbove.length; i++){
        const b = breakpointsAbove[i];
        if (b === void 0) continue;
        const layoutForBreakpoint = layouts[b];
        if (layoutForBreakpoint) {
            layout = layoutForBreakpoint;
            break;
        }
    }
    const clonedLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(layout || []);
    const corrected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["correctBounds"])(clonedLayout, {
        cols
    });
    const compactor = typeof compactTypeOrCompactor === "object" && compactTypeOrCompactor !== null ? compactTypeOrCompactor : getCompactor(compactTypeOrCompactor);
    return compactor.compact(corrected, cols);
}
function getIndentationValue(value, breakpoint) {
    if (Array.isArray(value)) {
        return value;
    }
    const breakpointMap = value;
    const breakpointValue = breakpointMap[breakpoint];
    if (breakpointValue !== void 0) {
        return breakpointValue;
    }
    const keys = Object.keys(breakpointMap);
    for (const key of keys){
        const v = breakpointMap[key];
        if (v !== void 0) {
            return v;
        }
    }
    return [
        10,
        10
    ];
}
;
 //# sourceMappingURL=chunk-XYPIYYYQ.mjs.map
 //# sourceMappingURL=chunk-XYPIYYYQ.mjs.map
}),
"[project]/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
        function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_ASYNC_MODE_TYPE:
                            case REACT_CONCURRENT_MODE_TYPE:
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        } // AsyncMode is deprecated along with isAsyncMode
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
                }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}
}),
"[project]/node_modules/react-is/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assign = Object.assign.bind(Object);
module.exports = assign;
module.exports.default = module.exports; //# sourceMappingURL=object-assign.js.map
}),
"[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;
}),
"[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}),
"[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
    var loggedTypeFailures = {};
    var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if ("TURBOPACK compile-time truthy", 1) {
        for(var typeSpecName in typeSpecs){
            if (has(typeSpecs, typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    if (typeof typeSpecs[typeSpecName] !== 'function') {
                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : '';
                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
                }
            }
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    if (("TURBOPACK compile-time value", "development") !== 'production') {
        loggedTypeFailures = {};
    }
};
module.exports = checkPropTypes;
}),
"[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactIs = __turbopack_context__.r("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
var assign = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)");
var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
var checkPropTypes = __turbopack_context__.r("[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)");
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
            return iteratorFn;
        }
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = '<<anonymous>>';
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bigint: createPrimitiveTypeChecker('bigint'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === 'object' ? data : {};
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        if (("TURBOPACK compile-time value", "development") !== 'production') {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                    err.name = 'Invariant Violation';
                    throw err;
                } else if (("TURBOPACK compile-time value", "development") !== 'production' && typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    }
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
                    expectedType: expectedType
                });
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (arguments.length > 1) {
                    printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
                } else {
                    printWarning('Invalid argument supplied to oneOf, expected an array.');
                }
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === 'symbol') {
                    return String(value);
                }
                return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for(var key in propValue){
                if (has(propValue, key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            ("TURBOPACK compile-time truthy", 1) ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : "TURBOPACK unreachable";
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                if (checkerResult == null) {
                    return null;
                }
                if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                    expectedTypes.push(checkerResult.data.expectedType);
                }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            // We need to check all keys in case some are required but missing from props.
            var allKeys = assign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (has(shapeTypes, key) && typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                if (!checker) {
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                    return true;
                }
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                        while(!(step = iterator.next()).done){
                            if (!isNode(step.value)) {
                                return false;
                            }
                        }
                    } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while(!(step = iterator.next()).done){
                            var entry = step.value;
                            if (entry) {
                                if (!isNode(entry[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    return false;
                }
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
            return true;
        }
        // falsy value can't be a Symbol
        if (!propValue) {
            return false;
        }
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
        }
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
        }
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return 'array';
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return 'object';
        }
        if (isSymbol(propType, propValue)) {
            return 'symbol';
        }
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) {
                return 'date';
            } else if (propValue instanceof RegExp) {
                return 'regexp';
            }
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
}),
"[project]/node_modules/prop-types/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ if ("TURBOPACK compile-time truthy", 1) {
    var ReactIs = __turbopack_context__.r("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = __turbopack_context__.r("[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)")(ReactIs.isElement, throwOnDirectAccess);
} else //TURBOPACK unreachable
;
}),
"[project]/node_modules/clsx/dist/clsx.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function r(e) {
    var o, t, f = "";
    if ("string" == typeof e || "number" == typeof e) f += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var n = e.length;
        for(o = 0; o < n; o++)e[o] && (t = r(e[o])) && (f && (f += " "), f += t);
    } else for(t in e)e[t] && (f && (f += " "), f += t);
    return f;
}
function e() {
    for(var e, o, t = 0, f = "", n = arguments.length; t < n; t++)(e = arguments[t]) && (o = r(e)) && (f && (f += " "), f += o);
    return f;
}
module.exports = e, module.exports.clsx = e;
}),
"[project]/node_modules/react-draggable/build/cjs/utils/shims.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dontSetMe = dontSetMe;
exports.findInArray = findInArray;
exports.int = int;
exports.isFunction = isFunction;
exports.isNum = isNum;
// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {
    for(let i = 0, length = array.length; i < length; i++){
        if (callback.apply(callback, [
            array[i],
            i,
            array
        ])) return array[i];
    }
}
function isFunction(func /*: any*/ ) /*: boolean %checks*/ {
    // $FlowIgnore[method-unbinding]
    return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}
function isNum(num /*: any*/ ) /*: boolean %checks*/ {
    return typeof num === 'number' && !isNaN(num);
}
function int(a /*: string*/ ) /*: number*/ {
    return parseInt(a, 10);
}
function dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {
    if (props[propName]) {
        return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);
    }
}
}),
"[project]/node_modules/react-draggable/build/cjs/utils/getPrefix.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.browserPrefixToKey = browserPrefixToKey;
exports.browserPrefixToStyle = browserPrefixToStyle;
exports.default = void 0;
exports.getPrefix = getPrefix;
const prefixes = [
    'Moz',
    'Webkit',
    'O',
    'ms'
];
function getPrefix() /*: string*/ {
    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
    // Ensure we're running in an environment where there is actually a global
    // `window` obj
    if (typeof window === 'undefined') return '';
    // If we're in a pseudo-browser server-side environment, this access
    // path may not exist, so bail out if it doesn't.
    const style = window.document?.documentElement?.style;
    if (!style) return '';
    if (prop in style) return '';
    for(let i = 0; i < prefixes.length; i++){
        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
    }
    return '';
}
function browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {
    return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;
}
function browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {
    return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;
}
function kebabToTitleCase(str /*: string*/ ) /*: string*/ {
    let out = '';
    let shouldCapitalize = true;
    for(let i = 0; i < str.length; i++){
        if (shouldCapitalize) {
            out += str[i].toUpperCase();
            shouldCapitalize = false;
        } else if (str[i] === '-') {
            shouldCapitalize = true;
        } else {
            out += str[i];
        }
    }
    return out;
}
// Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`
var _default = exports.default = getPrefix();
}),
"[project]/node_modules/react-draggable/build/cjs/utils/domFns.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addClassName = addClassName;
exports.addEvent = addEvent;
exports.addUserSelectStyles = addUserSelectStyles;
exports.createCSSTransform = createCSSTransform;
exports.createSVGTransform = createSVGTransform;
exports.getTouch = getTouch;
exports.getTouchIdentifier = getTouchIdentifier;
exports.getTranslation = getTranslation;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.matchesSelector = matchesSelector;
exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
exports.offsetXYFromParent = offsetXYFromParent;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.removeClassName = removeClassName;
exports.removeEvent = removeEvent;
exports.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;
var _shims = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/shims.js [app-client] (ecmascript)");
var _getPrefix = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/getPrefix.js [app-client] (ecmascript)"));
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = '';
function matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {
    if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)([
            'matches',
            'webkitMatchesSelector',
            'mozMatchesSelector',
            'msMatchesSelector',
            'oMatchesSelector'
        ], function(method) {
            // $FlowIgnore: Doesn't think elements are indexable
            return (0, _shims.isFunction)(el[method]);
        });
    }
    // Might not be found entirely (not an Element?) - in that case, bail
    // $FlowIgnore: Doesn't think elements are indexable
    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
    // $FlowIgnore: Doesn't think elements are indexable
    return el[matchesSelectorFunc](selector);
}
// Works up the tree to the draggable itself attempting to match selector.
function matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {
    let node = el;
    do {
        if (matchesSelector(node, selector)) return true;
        if (node === baseNode) return false;
        // $FlowIgnore[incompatible-type]
        node = node.parentNode;
    }while (node)
    return false;
}
function addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {
    if (!el) return;
    const options = {
        capture: true,
        ...inputOptions
    };
    // $FlowIgnore[method-unbinding]
    if (el.addEventListener) {
        el.addEventListener(event, handler, options);
    } else if (el.attachEvent) {
        el.attachEvent('on' + event, handler);
    } else {
        // $FlowIgnore: Doesn't think elements are indexable
        el['on' + event] = handler;
    }
}
function removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {
    if (!el) return;
    const options = {
        capture: true,
        ...inputOptions
    };
    // $FlowIgnore[method-unbinding]
    if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
    } else if (el.detachEvent) {
        el.detachEvent('on' + event, handler);
    } else {
        // $FlowIgnore: Doesn't think elements are indexable
        el['on' + event] = null;
    }
}
function outerHeight(node /*: HTMLElement*/ ) /*: number*/ {
    // This is deliberately excluding margin for our calculations, since we are using
    // offsetTop which is including margin. See getBoundPosition
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += (0, _shims.int)(computedStyle.borderTopWidth);
    height += (0, _shims.int)(computedStyle.borderBottomWidth);
    return height;
}
function outerWidth(node /*: HTMLElement*/ ) /*: number*/ {
    // This is deliberately excluding margin for our calculations, since we are using
    // offsetLeft which is including margin. See getBoundPosition
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += (0, _shims.int)(computedStyle.borderLeftWidth);
    width += (0, _shims.int)(computedStyle.borderRightWidth);
    return width;
}
function innerHeight(node /*: HTMLElement*/ ) /*: number*/ {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= (0, _shims.int)(computedStyle.paddingTop);
    height -= (0, _shims.int)(computedStyle.paddingBottom);
    return height;
}
function innerWidth(node /*: HTMLElement*/ ) /*: number*/ {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= (0, _shims.int)(computedStyle.paddingLeft);
    width -= (0, _shims.int)(computedStyle.paddingRight);
    return width;
}
/*:: interface EventWithOffset {
  clientX: number, clientY: number
}*/ // Get from offsetParent
function offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {
    const isBody = offsetParent === offsetParent.ownerDocument.body;
    const offsetParentRect = isBody ? {
        left: 0,
        top: 0
    } : offsetParent.getBoundingClientRect();
    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
    return {
        x,
        y
    };
}
function createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {
    const translation = getTranslation(controlPos, positionOffset, 'px');
    return {
        [(0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default)]: translation
    };
}
function createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {
    const translation = getTranslation(controlPos, positionOffset, '');
    return translation;
}
function getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {
    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;
    let translation = `translate(${x}${unitSuffix},${y}${unitSuffix})`;
    if (positionOffset) {
        const defaultX = `${typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix}`;
        const defaultY = `${typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix}`;
        translation = `translate(${defaultX}, ${defaultY})` + translation;
    }
    return translation;
}
function getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {
    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);
}
function getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {
    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
}
// User-select Hacks:
//
// Useful for preventing blue highlights all over everything when dragging.
// Note we're passing `document` b/c we could be iframed
function addUserSelectStyles(doc /*: ?Document*/ ) {
    if (!doc) return;
    let styleEl = doc.getElementById('react-draggable-style-el');
    if (!styleEl) {
        styleEl = doc.createElement('style');
        styleEl.type = 'text/css';
        styleEl.id = 'react-draggable-style-el';
        styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n';
        styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\n';
        doc.getElementsByTagName('head')[0].appendChild(styleEl);
    }
    if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
}
function scheduleRemoveUserSelectStyles(doc /*: ?Document*/ ) {
    // Prevent a possible "forced reflow"
    if (window.requestAnimationFrame) {
        window.requestAnimationFrame(()=>{
            removeUserSelectStyles(doc);
        });
    } else {
        removeUserSelectStyles(doc);
    }
}
function removeUserSelectStyles(doc /*: ?Document*/ ) {
    if (!doc) return;
    try {
        if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');
        // $FlowIgnore: IE
        if (doc.selection) {
            // $FlowIgnore: IE
            doc.selection.empty();
        } else {
            // Remove selection caused by scroll, unless it's a focused input
            // (we use doc.defaultView in case we're in an iframe)
            const selection = (doc.defaultView || window).getSelection();
            if (selection && selection.type !== 'Caret') {
                selection.removeAllRanges();
            }
        }
    } catch (e) {
    // probably IE
    }
}
function addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {
    if (el.classList) {
        el.classList.add(className);
    } else {
        if (!el.className.match(new RegExp(`(?:^|\\s)${className}(?!\\S)`))) {
            el.className += ` ${className}`;
        }
    }
}
function removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {
    if (el.classList) {
        el.classList.remove(className);
    } else {
        el.className = el.className.replace(new RegExp(`(?:^|\\s)${className}(?!\\S)`, 'g'), '');
    }
}
}),
"[project]/node_modules/react-draggable/build/cjs/utils/positionFns.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canDragX = canDragX;
exports.canDragY = canDragY;
exports.createCoreData = createCoreData;
exports.createDraggableData = createDraggableData;
exports.getBoundPosition = getBoundPosition;
exports.getControlPosition = getControlPosition;
exports.snapToGrid = snapToGrid;
var _shims = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/shims.js [app-client] (ecmascript)");
var _domFns = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/domFns.js [app-client] (ecmascript)");
/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {
    // If no bounds, short-circuit and move on
    if (!draggable.props.bounds) return [
        x,
        y
    ];
    // Clone new bounds
    let { bounds } = draggable.props;
    bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
    const node = findDOMNode(draggable);
    if (typeof bounds === 'string') {
        const { ownerDocument } = node;
        const ownerWindow = ownerDocument.defaultView;
        let boundNode;
        if (bounds === 'parent') {
            boundNode = node.parentNode;
        } else {
            // Flow assigns the wrong return type (Node) for getRootNode(),
            // so we cast it to one of the correct types (Element).
            // The others are Document and ShadowRoot.
            // All three implement querySelector() so it's safe to call.
            const rootNode = node.getRootNode();
            boundNode = rootNode.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
            throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly
        const nodeStyle = ownerWindow.getComputedStyle(node);
        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
        bounds = {
            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
    }
    // Keep x and y below right and bottom limits...
    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
    // But above left and top limits.
    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
    return [
        x,
        y
    ];
}
function snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {
    const x = Math.round(pendingX / grid[0]) * grid[0];
    const y = Math.round(pendingY / grid[1]) * grid[1];
    return [
        x,
        y
    ];
}
function canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {
    return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}
function canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {
    return draggable.props.axis === 'both' || draggable.props.axis === 'y';
}
// Get {x, y} positions from event.
function getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {
    const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
    if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
    const node = findDOMNode(draggableCore);
    // User can provide an offsetParent if desired.
    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
}
// Create an data object exposed by <DraggableCore>'s events
function createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {
    const isStart = !(0, _shims.isNum)(draggable.lastX);
    const node = findDOMNode(draggable);
    if (isStart) {
        // If this is our first move, use the x and y as last coords.
        return {
            node,
            deltaX: 0,
            deltaY: 0,
            lastX: x,
            lastY: y,
            x,
            y
        };
    } else {
        // Otherwise calculate proper values.
        return {
            node,
            deltaX: x - draggable.lastX,
            deltaY: y - draggable.lastY,
            lastX: draggable.lastX,
            lastY: draggable.lastY,
            x,
            y
        };
    }
}
// Create an data exposed by <Draggable>'s events
function createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {
    const scale = draggable.props.scale;
    return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
    };
}
// A lot faster than stringify/parse
function cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {
    return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
    };
}
function findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {
    const node = draggable.findDOMNode();
    if (!node) {
        throw new Error('<DraggableCore>: Unmounted during event!');
    }
    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME
    return node;
}
}),
"[project]/node_modules/react-draggable/build/cjs/utils/log.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = log;
/*eslint no-console:0*/ function log() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
}
}),
"[project]/node_modules/react-draggable/build/cjs/DraggableCore.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var React = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/prop-types/index.js [app-client] (ecmascript)"));
var _reactDom = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
var _domFns = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/domFns.js [app-client] (ecmascript)");
var _positionFns = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/positionFns.js [app-client] (ecmascript)");
var _shims = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/shims.js [app-client] (ecmascript)");
var _log = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/log.js [app-client] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.
const eventsFor = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend'
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup'
    }
};
// Default to mouse events.
let dragEventFor = eventsFor.mouse;
/*:: export type DraggableData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number,
};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {
  allowAnyClick: boolean,
  allowMobileScroll: boolean,
  disabled: boolean,
  enableUserSelectHack: boolean,
  onStart: DraggableEventHandler,
  onDrag: DraggableEventHandler,
  onStop: DraggableEventHandler,
  onMouseDown: (e: MouseEvent) => void,
  scale: number,
};*/ /*:: export type DraggableCoreProps = {
  ...DraggableCoreDefaultProps,
  cancel: string,
  children: ReactElement<any>,
  offsetParent: HTMLElement,
  grid: [number, number],
  handle: string,
  nodeRef?: ?React.ElementRef<any>,
};*/ //
// Define <DraggableCore>.
//
// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
// work well with libraries that require more control over the element.
//
class DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {
    constructor(){
        super(...arguments);
        _defineProperty(this, "dragging", false);
        // Used while dragging to determine deltas.
        _defineProperty(this, "lastX", NaN);
        _defineProperty(this, "lastY", NaN);
        _defineProperty(this, "touchIdentifier", null);
        _defineProperty(this, "mounted", false);
        _defineProperty(this, "handleDragStart", (e)=>{
            // Make it possible to attach event handlers on top of this one.
            this.props.onMouseDown(e);
            // Only accept left-clicks.
            if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;
            // Get nodes. Be sure to grab relative document (could be iframed)
            const thisNode = this.findDOMNode();
            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
                throw new Error('<DraggableCore> not mounted on DragStart!');
            }
            const { ownerDocument } = thisNode;
            // Short circuit if handle or cancel prop was provided and selector doesn't match.
            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {
                return;
            }
            // Prevent scrolling on mobile devices, like ipad/iphone.
            // Important that this is after handle/cancel.
            if (e.type === 'touchstart' && !this.props.allowMobileScroll) e.preventDefault();
            // Set touch identifier in component state if this is a touch event. This allows us to
            // distinguish between individual touches on multitouch screens by identifying which
            // touchpoint was set to this element.
            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
            this.touchIdentifier = touchIdentifier;
            // Get the current drag point from the event. This is used as the offset.
            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);
            if (position == null) return; // not possible but satisfies flow
            const { x, y } = position;
            // Create an event object with all the data parents need to make a decision here.
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);
            // Call event handler. If it returns explicit false, cancel.
            (0, _log.default)('calling', this.props.onStart);
            const shouldUpdate = this.props.onStart(e, coreEvent);
            if (shouldUpdate === false || this.mounted === false) return;
            // Add a style to the body to disable user-select. This prevents text from
            // being selected all over the page.
            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
            // Initiate dragging. Set the current x and y as offsets
            // so we know how much we've moved during the drag. This allows us
            // to drag elements around even if they have been moved, without issue.
            this.dragging = true;
            this.lastX = x;
            this.lastY = y;
            // Add events to the document directly so we catch when the user's mouse/touch moves outside of
            // this element. We use different events depending on whether or not we have detected that this
            // is a touch-capable device.
            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
        });
        _defineProperty(this, "handleDrag", (e)=>{
            // Get the current drag point from the event. This is used as the offset.
            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
            if (position == null) return;
            let { x, y } = position;
            // Snap to grid if prop has been provided
            if (Array.isArray(this.props.grid)) {
                let deltaX = x - this.lastX, deltaY = y - this.lastY;
                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
                if (!deltaX && !deltaY) return; // skip useless drag
                x = this.lastX + deltaX, y = this.lastY + deltaY;
            }
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);
            // Call event handler. If it returns explicit false, trigger end.
            const shouldUpdate = this.props.onDrag(e, coreEvent);
            if (shouldUpdate === false || this.mounted === false) {
                try {
                    // $FlowIgnore
                    this.handleDragStop(new MouseEvent('mouseup'));
                } catch (err) {
                    // Old browsers
                    const event = document.createEvent('MouseEvents');
                    // I see why this insanity was deprecated
                    // $FlowIgnore
                    event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    this.handleDragStop(event);
                }
                return;
            }
            this.lastX = x;
            this.lastY = y;
        });
        _defineProperty(this, "handleDragStop", (e)=>{
            if (!this.dragging) return;
            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
            if (position == null) return;
            let { x, y } = position;
            // Snap to grid if prop has been provided
            if (Array.isArray(this.props.grid)) {
                let deltaX = x - this.lastX || 0;
                let deltaY = y - this.lastY || 0;
                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
                x = this.lastX + deltaX, y = this.lastY + deltaY;
            }
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            // Call event handler
            const shouldContinue = this.props.onStop(e, coreEvent);
            if (shouldContinue === false || this.mounted === false) return false;
            const thisNode = this.findDOMNode();
            if (thisNode) {
                // Remove user-select hack
                if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);
            }
            (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);
            // Reset the el.
            this.dragging = false;
            this.lastX = NaN;
            this.lastY = NaN;
            if (thisNode) {
                // Remove event handlers
                (0, _log.default)('DraggableCore: Removing handlers');
                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
            }
        });
        _defineProperty(this, "onMouseDown", (e)=>{
            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse
            return this.handleDragStart(e);
        });
        _defineProperty(this, "onMouseUp", (e)=>{
            dragEventFor = eventsFor.mouse;
            return this.handleDragStop(e);
        });
        // Same as onMouseDown (start drag), but now consider this a touch device.
        _defineProperty(this, "onTouchStart", (e)=>{
            // We're on a touch device now, so change the event handlers
            dragEventFor = eventsFor.touch;
            return this.handleDragStart(e);
        });
        _defineProperty(this, "onTouchEnd", (e)=>{
            // We're on a touch device now, so change the event handlers
            dragEventFor = eventsFor.touch;
            return this.handleDragStop(e);
        });
    }
    componentDidMount() {
        this.mounted = true;
        // Touch handlers must be added with {passive: false} to be cancelable.
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        const thisNode = this.findDOMNode();
        if (thisNode) {
            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
                passive: false
            });
        }
    }
    componentWillUnmount() {
        this.mounted = false;
        // Remove any leftover event handlers. Remove both touch and mouse handlers in case
        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
        const thisNode = this.findDOMNode();
        if (thisNode) {
            const { ownerDocument } = thisNode;
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
                passive: false
            });
            if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);
        }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() /*: ?HTMLElement*/ {
        return this.props?.nodeRef ? this.props?.nodeRef?.current : _reactDom.default.findDOMNode(this);
    }
    render() /*: React.Element<any>*/ {
        // Reuse the child provided
        // This makes it flexible to use whatever element is wanted (div, ul, etc)
        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {
            // Note: mouseMove handler is attached to document so it will still function
            // when the user drags quickly and leaves the bounds of the element.
            onMouseDown: this.onMouseDown,
            onMouseUp: this.onMouseUp,
            // onTouchStart is added on `componentDidMount` so they can be added with
            // {passive: false}, which allows it to cancel. See
            // https://developers.google.com/web/updates/2017/01/scrolling-intervention
            onTouchEnd: this.onTouchEnd
        });
    }
}
exports.default = DraggableCore;
_defineProperty(DraggableCore, "displayName", 'DraggableCore');
_defineProperty(DraggableCore, "propTypes", {
    /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */ allowAnyClick: _propTypes.default.bool,
    /**
   * `allowMobileScroll` turns off cancellation of the 'touchstart' event
   * on mobile devices. Only enable this if you are having trouble with click
   * events. Prefer using 'handle' / 'cancel' instead.
   *
   * Defaults to `false`.
   */ allowMobileScroll: _propTypes.default.bool,
    children: _propTypes.default.node.isRequired,
    /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */ disabled: _propTypes.default.bool,
    /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */ enableUserSelectHack: _propTypes.default.bool,
    /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {
        if (props[propName] && props[propName].nodeType !== 1) {
            throw new Error('Draggable\'s offsetParent must be a DOM Node.');
        }
    },
    /**
   * `grid` specifies the x and y that dragging should snap to.
   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),
    /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */ handle: _propTypes.default.string,
    /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */ cancel: _propTypes.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */ nodeRef: _propTypes.default.object,
    /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */ onStart: _propTypes.default.func,
    /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */ onDrag: _propTypes.default.func,
    /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */ onStop: _propTypes.default.func,
    /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */ onMouseDown: _propTypes.default.func,
    /**
   * `scale`, if set, applies scaling while dragging an element
   */ scale: _propTypes.default.number,
    /**
   * These properties should be defined on the child, not here.
   */ className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
});
_defineProperty(DraggableCore, "defaultProps", {
    allowAnyClick: false,
    // by default only accept left click
    allowMobileScroll: false,
    disabled: false,
    enableUserSelectHack: true,
    onStart: function() {},
    onDrag: function() {},
    onStop: function() {},
    onMouseDown: function() {},
    scale: 1
});
}),
"[project]/node_modules/react-draggable/build/cjs/Draggable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "DraggableCore", {
    enumerable: true,
    get: function() {
        return _DraggableCore.default;
    }
});
exports.default = void 0;
var React = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/prop-types/index.js [app-client] (ecmascript)"));
var _reactDom = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
var _clsx = __turbopack_context__.r("[project]/node_modules/clsx/dist/clsx.js [app-client] (ecmascript)");
var _domFns = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/domFns.js [app-client] (ecmascript)");
var _positionFns = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/positionFns.js [app-client] (ecmascript)");
var _shims = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/shims.js [app-client] (ecmascript)");
var _DraggableCore = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/DraggableCore.js [app-client] (ecmascript)"));
var _log = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/utils/log.js [app-client] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ 
/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {
  dragging: boolean,
  dragged: boolean,
  x: number, y: number,
  slackX: number, slackY: number,
  isElementSVG: boolean,
  prevPropsPosition: ?ControlPosition,
};*/ /*:: export type DraggableDefaultProps = {
  ...DraggableCoreDefaultProps,
  axis: 'both' | 'x' | 'y' | 'none',
  bounds: Bounds | string | false,
  defaultClassName: string,
  defaultClassNameDragging: string,
  defaultClassNameDragged: string,
  defaultPosition: ControlPosition,
  scale: number,
};*/ /*:: export type DraggableProps = {
  ...DraggableCoreProps,
  ...DraggableDefaultProps,
  positionOffset: PositionOffsetControlPosition,
  position: ControlPosition,
};*/ //
// Define <Draggable>
//
class Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {
    // React 16.3+
    // Arity (props, state)
    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {
        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;
        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;
        // Set x/y if a new position is provided in props that is different than the previous.
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
            (0, _log.default)('Draggable: getDerivedStateFromProps %j', {
                position,
                prevPropsPosition
            });
            return {
                x: position.x,
                y: position.y,
                prevPropsPosition: {
                    ...position
                }
            };
        }
        return null;
    }
    constructor(props /*: DraggableProps*/ ){
        super(props);
        _defineProperty(this, "onDragStart", (e, coreData)=>{
            (0, _log.default)('Draggable: onDragStart: %j', coreData);
            // Short-circuit if user's callback killed it.
            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));
            // Kills start event on core as well, so move handlers are never bound.
            if (shouldStart === false) return false;
            this.setState({
                dragging: true,
                dragged: true
            });
        });
        _defineProperty(this, "onDrag", (e, coreData)=>{
            if (!this.state.dragging) return false;
            (0, _log.default)('Draggable: onDrag: %j', coreData);
            const uiData = (0, _positionFns.createDraggableData)(this, coreData);
            const newState = {
                x: uiData.x,
                y: uiData.y,
                slackX: 0,
                slackY: 0
            };
            // Keep within bounds.
            if (this.props.bounds) {
                // Save original x and y.
                const { x, y } = newState;
                // Add slack to the values used to calculate bound position. This will ensure that if
                // we start removing slack, the element won't react to it right away until it's been
                // completely removed.
                newState.x += this.state.slackX;
                newState.y += this.state.slackY;
                // Get bound position. This will ceil/floor the x and y within the boundaries.
                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
                newState.x = newStateX;
                newState.y = newStateY;
                // Recalculate slack by noting how much was shaved by the boundPosition handler.
                newState.slackX = this.state.slackX + (x - newState.x);
                newState.slackY = this.state.slackY + (y - newState.y);
                // Update the event we fire to reflect what really happened after bounds took effect.
                uiData.x = newState.x;
                uiData.y = newState.y;
                uiData.deltaX = newState.x - this.state.x;
                uiData.deltaY = newState.y - this.state.y;
            }
            // Short-circuit if user's callback killed it.
            const shouldUpdate = this.props.onDrag(e, uiData);
            if (shouldUpdate === false) return false;
            this.setState(newState);
        });
        _defineProperty(this, "onDragStop", (e, coreData)=>{
            if (!this.state.dragging) return false;
            // Short-circuit if user's callback killed it.
            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));
            if (shouldContinue === false) return false;
            (0, _log.default)('Draggable: onDragStop: %j', coreData);
            const newState /*: Partial<DraggableState>*/  = {
                dragging: false,
                slackX: 0,
                slackY: 0
            };
            // If this is a controlled component, the result of this operation will be to
            // revert back to the old position. We expect a handler on `onDragStop`, at the least.
            const controlled = Boolean(this.props.position);
            if (controlled) {
                const { x, y } = this.props.position;
                newState.x = x;
                newState.y = y;
            }
            this.setState(newState);
        });
        this.state = {
            // Whether or not we are currently dragging.
            dragging: false,
            // Whether or not we have been dragged before.
            dragged: false,
            // Current transform x and y.
            x: props.position ? props.position.x : props.defaultPosition.x,
            y: props.position ? props.position.y : props.defaultPosition.y,
            prevPropsPosition: {
                ...props.position
            },
            // Used for compensating for out-of-bounds drags
            slackX: 0,
            slackY: 0,
            // Can only determine if SVG after mounting
            isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
            // eslint-disable-next-line no-console
            console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
        }
    }
    componentDidMount() {
        // Check to see if the element passed is an instanceof SVGElement
        if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {
            this.setState({
                isElementSVG: true
            });
        }
    }
    componentWillUnmount() {
        if (this.state.dragging) {
            this.setState({
                dragging: false
            }); // prevents invariant if unmounted while dragging
        }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() /*: ?HTMLElement*/ {
        return this.props?.nodeRef?.current ?? _reactDom.default.findDOMNode(this);
    }
    render() /*: ReactElement<any>*/ {
        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;
        let style = {};
        let svgTransform = null;
        // If this is controlled, we don't want to move it - unless it's dragging.
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
            // Set left if horizontal drag is enabled
            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
            // Set top if vertical drag is enabled
            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        // If this element was SVG, we use the `transform` attribute.
        if (this.state.isElementSVG) {
            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        } else {
            // Add a CSS transform to move the element around. This allows us to move the element around
            // without worrying about whether or not it is relatively or absolutely positioned.
            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
            // has a clean slate.
            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        }
        // Mark with class while dragging
        const className = (0, _clsx.clsx)(children.props.className || '', defaultClassName, {
            [defaultClassNameDragging]: this.state.dragging,
            [defaultClassNameDragged]: this.state.dragged
        });
        // Reuse the child provided
        // This makes it flexible to use whatever element is wanted (div, ul, etc)
        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop
        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {
            className: className,
            style: {
                ...children.props.style,
                ...style
            },
            transform: svgTransform
        }));
    }
}
exports.default = Draggable;
_defineProperty(Draggable, "displayName", 'Draggable');
_defineProperty(Draggable, "propTypes", {
    // Accepts all props <DraggableCore> accepts.
    ..._DraggableCore.default.propTypes,
    /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */ axis: _propTypes.default.oneOf([
        'both',
        'x',
        'y',
        'none'
    ]),
    /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */ bounds: _propTypes.default.oneOfType([
        _propTypes.default.shape({
            left: _propTypes.default.number,
            right: _propTypes.default.number,
            top: _propTypes.default.number,
            bottom: _propTypes.default.number
        }),
        _propTypes.default.string,
        _propTypes.default.oneOf([
            false
        ])
    ]),
    defaultClassName: _propTypes.default.string,
    defaultClassNameDragging: _propTypes.default.string,
    defaultClassNameDragged: _propTypes.default.string,
    /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */ defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
    }),
    positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([
            _propTypes.default.number,
            _propTypes.default.string
        ]),
        y: _propTypes.default.oneOfType([
            _propTypes.default.number,
            _propTypes.default.string
        ])
    }),
    /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */ position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
    }),
    /**
   * These properties should be defined on the child, not here.
   */ className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
});
_defineProperty(Draggable, "defaultProps", {
    ..._DraggableCore.default.defaultProps,
    axis: 'both',
    bounds: false,
    defaultClassName: 'react-draggable',
    defaultClassNameDragging: 'react-draggable-dragging',
    defaultClassNameDragged: 'react-draggable-dragged',
    defaultPosition: {
        x: 0,
        y: 0
    },
    scale: 1
});
}),
"[project]/node_modules/react-draggable/build/cjs/cjs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { default: Draggable, DraggableCore } = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/Draggable.js [app-client] (ecmascript)");
// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.
// See https://github.com/mzabriskie/react-draggable/pull/254
// and https://github.com/mzabriskie/react-draggable/issues/266
module.exports = Draggable;
module.exports.default = Draggable;
module.exports.DraggableCore = DraggableCore;
}),
"[project]/node_modules/react-resizable/build/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.cloneElement = cloneElement;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
// React.addons.cloneWithProps look-alike that merges style & className.
function cloneElement(element, props) {
    if (props.style && element.props.style) {
        props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);
    }
    if (props.className && element.props.className) {
        props.className = `${element.props.className} ${props.className}`;
    }
    return /*#__PURE__*/ _react.default.cloneElement(element, props);
}
}),
"[project]/node_modules/react-resizable/build/propTypes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.resizableProps = void 0;
var _propTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/prop-types/index.js [app-client] (ecmascript)"));
var _reactDraggable = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/cjs.js [app-client] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
/* global Element */ // <Resizable>
const resizableProps = exports.resizableProps = {
    /*
  * Restricts resizing to a particular axis (default: 'both')
  * 'both' - allows resizing by width or height
  * 'x' - only allows the width to be changed
  * 'y' - only allows the height to be changed
  * 'none' - disables resizing altogether
  * */ axis: _propTypes.default.oneOf([
        'both',
        'x',
        'y',
        'none'
    ]),
    className: _propTypes.default.string,
    /*
  * Require that one and only one child be present.
  * */ children: _propTypes.default.element.isRequired,
    /*
  * These will be passed wholesale to react-draggable's DraggableCore
  * */ draggableOpts: _propTypes.default.shape({
        allowAnyClick: _propTypes.default.bool,
        cancel: _propTypes.default.string,
        children: _propTypes.default.node,
        disabled: _propTypes.default.bool,
        enableUserSelectHack: _propTypes.default.bool,
        // #251: Check for Element to support SSR environments where DOM globals don't exist
        offsetParent: typeof Element !== 'undefined' ? _propTypes.default.instanceOf(Element) : _propTypes.default.any,
        grid: _propTypes.default.arrayOf(_propTypes.default.number),
        handle: _propTypes.default.string,
        nodeRef: _propTypes.default.object,
        onStart: _propTypes.default.func,
        onDrag: _propTypes.default.func,
        onStop: _propTypes.default.func,
        onMouseDown: _propTypes.default.func,
        scale: _propTypes.default.number
    }),
    /*
  * Initial height
  * */ height: function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const [props] = args;
        // Required if resizing height or both
        if (props.axis === 'both' || props.axis === 'y') {
            return _propTypes.default.number.isRequired(...args);
        }
        return _propTypes.default.number(...args);
    },
    /*
  * Customize cursor resize handle
  * */ handle: _propTypes.default.oneOfType([
        _propTypes.default.node,
        _propTypes.default.func
    ]),
    /*
  * If you change this, be sure to update your css
  * */ handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
    lockAspectRatio: _propTypes.default.bool,
    /*
  * Max X & Y measure
  * */ maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
  * Min X & Y measure
  * */ minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
  * Called on stop resize event
  * */ onResizeStop: _propTypes.default.func,
    /*
  * Called on start resize event
  * */ onResizeStart: _propTypes.default.func,
    /*
  * Called on resize event
  * */ onResize: _propTypes.default.func,
    /*
  * Defines which resize handles should be rendered (default: 'se')
  * 's' - South handle (bottom-center)
  * 'w' - West handle (left-center)
  * 'e' - East handle (right-center)
  * 'n' - North handle (top-center)
  * 'sw' - Southwest handle (bottom-left)
  * 'nw' - Northwest handle (top-left)
  * 'se' - Southeast handle (bottom-right)
  * 'ne' - Northeast handle (top-center)
  * */ resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf([
        's',
        'w',
        'e',
        'n',
        'sw',
        'nw',
        'se',
        'ne'
    ])),
    /*
  * If `transform: scale(n)` is set on the parent, this should be set to `n`.
  * */ transformScale: _propTypes.default.number,
    /*
   * Initial width
   */ width: function() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        const [props] = args;
        // Required if resizing width or both
        if (props.axis === 'both' || props.axis === 'x') {
            return _propTypes.default.number.isRequired(...args);
        }
        return _propTypes.default.number(...args);
    }
};
}),
"[project]/node_modules/react-resizable/build/Resizable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.default = void 0;
var React = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _reactDraggable = __turbopack_context__.r("[project]/node_modules/react-draggable/build/cjs/cjs.js [app-client] (ecmascript)");
var _utils = __turbopack_context__.r("[project]/node_modules/react-resizable/build/utils.js [app-client] (ecmascript)");
var _propTypes = __turbopack_context__.r("[project]/node_modules/react-resizable/build/propTypes.js [app-client] (ecmascript)");
const _excluded = [
    "children",
    "className",
    "draggableOpts",
    "width",
    "height",
    "handle",
    "handleSize",
    "lockAspectRatio",
    "axis",
    "minConstraints",
    "maxConstraints",
    "onResize",
    "onResizeStop",
    "onResizeStart",
    "resizeHandles",
    "transformScale"
];
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
// The base <Resizable> component.
// This component does not have state and relies on the parent to set its props based on callback data.
class Resizable extends React.Component {
    constructor(){
        super(...arguments);
        this.handleRefs = {};
        this.lastHandleRect = null;
        this.slack = null;
        this.lastSize = null;
    }
    componentWillUnmount() {
        this.resetData();
    }
    resetData() {
        this.lastHandleRect = this.slack = this.lastSize = null;
    }
    // Clamp width and height within provided constraints
    runConstraints(width, height) {
        const { minConstraints, maxConstraints, lockAspectRatio } = this.props;
        // short circuit
        if (!minConstraints && !maxConstraints && !lockAspectRatio) return [
            width,
            height
        ];
        // If constraining to min and max, we need to also fit width and height to aspect ratio.
        if (lockAspectRatio) {
            const ratio = this.props.width / this.props.height;
            const deltaW = width - this.props.width;
            const deltaH = height - this.props.height;
            // Find which coordinate was greater and should push the other toward it.
            // E.g.:
            // ratio = 1, deltaW = 10, deltaH = 5, deltaH should become 10.
            // ratio = 2, deltaW = 10, deltaH = 6, deltaW should become 12.
            if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
                height = width / ratio;
            } else {
                width = height * ratio;
            }
        }
        const [oldW, oldH] = [
            width,
            height
        ];
        // Add slack to the values used to calculate bound position. This will ensure that if
        // we start removing slack, the element won't react to it right away until it's been
        // completely removed.
        let [slackW, slackH] = this.slack || [
            0,
            0
        ];
        width += slackW;
        height += slackH;
        if (minConstraints) {
            width = Math.max(minConstraints[0], width);
            height = Math.max(minConstraints[1], height);
        }
        if (maxConstraints) {
            width = Math.min(maxConstraints[0], width);
            height = Math.min(maxConstraints[1], height);
        }
        // If the width or height changed, we must have introduced some slack. Record it for the next iteration.
        this.slack = [
            slackW + (oldW - width),
            slackH + (oldH - height)
        ];
        return [
            width,
            height
        ];
    }
    /**
   * Wrapper around drag events to provide more useful data.
   *
   * @param  {String} handlerName Handler name to wrap.
   * @return {Function}           Handler function.
   */ resizeHandler(handlerName, axis) {
        return (e, _ref)=>{
            let { node, deltaX, deltaY } = _ref;
            // Reset data in case it was left over somehow (should not be possible)
            if (handlerName === 'onResizeStart') this.resetData();
            // Axis restrictions
            const canDragX = (this.props.axis === 'both' || this.props.axis === 'x') && axis !== 'n' && axis !== 's';
            const canDragY = (this.props.axis === 'both' || this.props.axis === 'y') && axis !== 'e' && axis !== 'w';
            // No dragging possible.
            if (!canDragX && !canDragY) return;
            // Decompose axis for later use
            const axisV = axis[0];
            const axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example
            // Track the element being dragged to account for changes in position.
            // If a handle's position is changed between callbacks, we need to factor this in to the next callback.
            // Failure to do so will cause the element to "skip" when resized upwards or leftwards.
            const handleRect = node.getBoundingClientRect();
            if (this.lastHandleRect != null) {
                // If the handle has repositioned on either axis since last render,
                // we need to increase our callback values by this much.
                // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,
                if (axisH === 'w') {
                    const deltaLeftSinceLast = handleRect.left - this.lastHandleRect.left;
                    deltaX += deltaLeftSinceLast;
                }
                if (axisV === 'n') {
                    const deltaTopSinceLast = handleRect.top - this.lastHandleRect.top;
                    deltaY += deltaTopSinceLast;
                }
            }
            // Storage of last rect so we know how much it has really moved.
            this.lastHandleRect = handleRect;
            // Reverse delta if using top or left drag handles.
            if (axisH === 'w') deltaX = -deltaX;
            if (axisV === 'n') deltaY = -deltaY;
            // Update w/h by the deltas. Also factor in transformScale.
            let width = this.props.width + (canDragX ? deltaX / this.props.transformScale : 0);
            let height = this.props.height + (canDragY ? deltaY / this.props.transformScale : 0);
            // Run user-provided constraints.
            [width, height] = this.runConstraints(width, height);
            // For onResizeStop, use the last size from onResize rather than recalculating.
            // This avoids issues where props.width/height are stale due to React's batched updates.
            if (handlerName === 'onResizeStop' && this.lastSize) {
                ({ width, height } = this.lastSize);
            }
            const dimensionsChanged = width !== this.props.width || height !== this.props.height;
            // Store the size for use in onResizeStop. We do this after the onResizeStop check
            // above so we don't overwrite the stored value with a potentially stale calculation.
            if (handlerName !== 'onResizeStop') {
                this.lastSize = {
                    width,
                    height
                };
            }
            // Call user-supplied callback if present.
            const cb = typeof this.props[handlerName] === 'function' ? this.props[handlerName] : null;
            // Don't call 'onResize' if dimensions haven't changed.
            const shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;
            if (cb && !shouldSkipCb) {
                e.persist?.();
                cb(e, {
                    node,
                    size: {
                        width,
                        height
                    },
                    handle: axis
                });
            }
            // Reset internal data
            if (handlerName === 'onResizeStop') this.resetData();
        };
    }
    // Render a resize handle given an axis & DOM ref. Ref *must* be attached for
    // the underlying draggable library to work properly.
    renderResizeHandle(handleAxis, ref) {
        const { handle } = this.props;
        // No handle provided, make the default
        if (!handle) {
            return /*#__PURE__*/ React.createElement("span", {
                className: `react-resizable-handle react-resizable-handle-${handleAxis}`,
                ref: ref
            });
        }
        // Handle is a function, such as:
        // `handle={(handleAxis) => <span className={...} />}`
        if (typeof handle === 'function') {
            return handle(handleAxis, ref);
        }
        // Handle is a React component (composite or DOM).
        const isDOMElement = typeof handle.type === 'string';
        const props = _objectSpread({
            ref
        }, isDOMElement ? {} : {
            handleAxis
        });
        return /*#__PURE__*/ React.cloneElement(handle, props);
    }
    render() {
        // Pass along only props not meant for the `<Resizable>`.`
        // eslint-disable-next-line no-unused-vars
        const _this$props = this.props, { children, className, draggableOpts, width, height, handle, handleSize, lockAspectRatio, axis, minConstraints, maxConstraints, onResize, onResizeStop, onResizeStart, resizeHandles, transformScale } = _this$props, p = _objectWithoutProperties(_this$props, _excluded);
        // What we're doing here is getting the child of this element, and cloning it with this element's props.
        // We are then defining its children as:
        // 1. Its original children (resizable's child's children), and
        // 2. One or more draggable handles.
        return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {
            className: `${className ? `${className} ` : ''}react-resizable`,
            children: [
                ...React.Children.toArray(children.props.children),
                ...resizeHandles.map((handleAxis)=>{
                    // Create a ref to the handle so that `<DraggableCore>` doesn't have to use ReactDOM.findDOMNode().
                    const ref = this.handleRefs[handleAxis] ?? (this.handleRefs[handleAxis] = /*#__PURE__*/ React.createRef());
                    return /*#__PURE__*/ React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {
                        nodeRef: ref,
                        key: `resizableHandle-${handleAxis}`,
                        onStop: this.resizeHandler('onResizeStop', handleAxis),
                        onStart: this.resizeHandler('onResizeStart', handleAxis),
                        onDrag: this.resizeHandler('onResize', handleAxis)
                    }), this.renderResizeHandle(handleAxis, ref));
                })
            ]
        }));
    }
}
exports.default = Resizable;
Resizable.propTypes = _propTypes.resizableProps;
Resizable.defaultProps = {
    axis: 'both',
    handleSize: [
        20,
        20
    ],
    lockAspectRatio: false,
    minConstraints: [
        20,
        20
    ],
    maxConstraints: [
        Infinity,
        Infinity
    ],
    resizeHandles: [
        'se'
    ],
    transformScale: 1
};
}),
"[project]/node_modules/react-resizable/build/ResizableBox.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.default = void 0;
var React = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/prop-types/index.js [app-client] (ecmascript)"));
var _Resizable = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-resizable/build/Resizable.js [app-client] (ecmascript)"));
var _propTypes2 = __turbopack_context__.r("[project]/node_modules/react-resizable/build/propTypes.js [app-client] (ecmascript)");
const _excluded = [
    "handle",
    "handleSize",
    "onResize",
    "onResizeStart",
    "onResizeStop",
    "draggableOpts",
    "minConstraints",
    "maxConstraints",
    "lockAspectRatio",
    "axis",
    "width",
    "height",
    "resizeHandles",
    "style",
    "transformScale"
];
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
// ElementConfig gives us an object type where all items present in `defaultProps` are made optional.
// <ResizableBox> does not have defaultProps, so we can use this type to tell Flow that we don't
// care about that and will handle it in <Resizable> instead.
// A <ResizableBox> can also have a `style` property.
class ResizableBox extends React.Component {
    constructor(){
        super(...arguments);
        this.state = {
            width: this.props.width,
            height: this.props.height,
            propsWidth: this.props.width,
            propsHeight: this.props.height
        };
        this.onResize = (e, data)=>{
            const { size } = data;
            if (this.props.onResize) {
                e.persist?.();
                this.setState(size, ()=>this.props.onResize && this.props.onResize(e, data));
            } else {
                this.setState(size);
            }
        };
    }
    static getDerivedStateFromProps(props, state) {
        // If parent changes height/width, set that in our state.
        if (state.propsWidth !== props.width || state.propsHeight !== props.height) {
            return {
                width: props.width,
                height: props.height,
                propsWidth: props.width,
                propsHeight: props.height
            };
        }
        return null;
    }
    render() {
        // Basic wrapper around a Resizable instance.
        // If you use Resizable directly, you are responsible for updating the child component
        // with a new width and height.
        const _this$props = this.props, { handle, handleSize, onResize, onResizeStart, onResizeStop, draggableOpts, minConstraints, maxConstraints, lockAspectRatio, axis, width, height, resizeHandles, style, transformScale } = _this$props, props = _objectWithoutProperties(_this$props, _excluded);
        return /*#__PURE__*/ React.createElement(_Resizable.default, {
            axis: axis,
            draggableOpts: draggableOpts,
            handle: handle,
            handleSize: handleSize,
            height: this.state.height,
            lockAspectRatio: lockAspectRatio,
            maxConstraints: maxConstraints,
            minConstraints: minConstraints,
            onResizeStart: onResizeStart,
            onResize: this.onResize,
            onResizeStop: onResizeStop,
            resizeHandles: resizeHandles,
            transformScale: transformScale,
            width: this.state.width
        }, /*#__PURE__*/ React.createElement("div", _extends({}, props, {
            style: _objectSpread(_objectSpread({}, style), {}, {
                width: this.state.width + 'px',
                height: this.state.height + 'px'
            })
        })));
    }
}
exports.default = ResizableBox;
// PropTypes are identical to <Resizable>, except that children are not strictly required to be present.
ResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {
    children: _propTypes.default.element
});
}),
"[project]/node_modules/react-resizable/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function() {
    throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
};
module.exports.Resizable = __turbopack_context__.r("[project]/node_modules/react-resizable/build/Resizable.js [app-client] (ecmascript)").default;
module.exports.ResizableBox = __turbopack_context__.r("[project]/node_modules/react-resizable/build/ResizableBox.js [app-client] (ecmascript)").default;
}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/fast-equals/dist/fast-equals.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? factory(exports) : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function(exports1) {
    'use strict';
    /**
   * Default equality comparator pass-through, used as the standard `isEqual` creator for
   * use inside the built comparator.
   */ function createDefaultIsNestedEqual(comparator) {
        return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
            return comparator(a, b, meta);
        };
    }
    /**
   * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing
   * for circular references to be safely included in the comparison without creating
   * stack overflows.
   */ function createIsCircular(areItemsEqual) {
        return function isCircular(a, b, isEqual, cache) {
            if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {
                return areItemsEqual(a, b, isEqual, cache);
            }
            var cachedA = cache.get(a);
            var cachedB = cache.get(b);
            if (cachedA && cachedB) {
                return cachedA === b && cachedB === a;
            }
            cache.set(a, b);
            cache.set(b, a);
            var result = areItemsEqual(a, b, isEqual, cache);
            cache.delete(a);
            cache.delete(b);
            return result;
        };
    }
    /**
   * Targeted shallow merge of two objects.
   *
   * @NOTE
   * This exists as a tinier compiled version of the `__assign` helper that
   * `tsc` injects in case of `Object.assign` not being present.
   */ function merge(a, b) {
        var merged = {};
        for(var key in a){
            merged[key] = a[key];
        }
        for(var key in b){
            merged[key] = b[key];
        }
        return merged;
    }
    /**
   * Whether the value is a plain object.
   *
   * @NOTE
   * This is a same-realm compariosn only.
   */ function isPlainObject(value) {
        return value.constructor === Object || value.constructor == null;
    }
    /**
   * When the value is `Promise`-like, aka "then-able".
   */ function isPromiseLike(value) {
        return typeof value.then === 'function';
    }
    /**
   * Whether the values passed are strictly equal or both NaN.
   */ function sameValueZeroEqual(a, b) {
        return a === b || a !== a && b !== b;
    }
    var ARGUMENTS_TAG = '[object Arguments]';
    var BOOLEAN_TAG = '[object Boolean]';
    var DATE_TAG = '[object Date]';
    var REG_EXP_TAG = '[object RegExp]';
    var MAP_TAG = '[object Map]';
    var NUMBER_TAG = '[object Number]';
    var OBJECT_TAG = '[object Object]';
    var SET_TAG = '[object Set]';
    var STRING_TAG = '[object String]';
    var toString = Object.prototype.toString;
    function createComparator(_a) {
        var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;
        var isEqual = createIsNestedEqual(comparator);
        /**
       * compare the value of the two objects and return true if they are equivalent in values
       */ function comparator(a, b, meta) {
            // If the items are strictly equal, no need to do a value comparison.
            if (a === b) {
                return true;
            }
            // If the items are not non-nullish objects, then the only possibility
            // of them being equal but not strictly is if they are both `NaN`. Since
            // `NaN` is uniquely not equal to itself, we can use self-comparison of
            // both objects, which is faster than `isNaN()`.
            if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {
                return a !== a && b !== b;
            }
            // Checks are listed in order of commonality of use-case:
            //   1. Common complex object types (plain object, array)
            //   2. Common data values (date, regexp)
            //   3. Less-common complex object types (map, set)
            //   4. Less-common data values (promise, primitive wrappers)
            // Inherently this is both subjective and assumptive, however
            // when reviewing comparable libraries in the wild this order
            // appears to be generally consistent.
            // `isPlainObject` only checks against the object's own realm. Cross-realm
            // comparisons are rare, and will be handled in the ultimate fallback, so
            // we can avoid the `toString.call()` cost unless necessary.
            if (isPlainObject(a) && isPlainObject(b)) {
                return areObjectsEqual(a, b, isEqual, meta);
            }
            // `isArray()` works on subclasses and is cross-realm, so we can again avoid
            // the `toString.call()` cost unless necessary by just checking if either
            // and then both are arrays.
            var aArray = Array.isArray(a);
            var bArray = Array.isArray(b);
            if (aArray || bArray) {
                return aArray === bArray && areArraysEqual(a, b, isEqual, meta);
            }
            // Since this is a custom object, use the classic `toString.call()` to get its
            // type. This is reasonably performant in modern environments like v8 and
            // SpiderMonkey, and allows for cross-realm comparison when other checks like
            // `instanceof` do not.
            var aTag = toString.call(a);
            if (aTag !== toString.call(b)) {
                return false;
            }
            if (aTag === DATE_TAG) {
                // `getTime()` showed better results compared to alternatives like `valueOf()`
                // or the unary `+` operator.
                return areDatesEqual(a, b, isEqual, meta);
            }
            if (aTag === REG_EXP_TAG) {
                return areRegExpsEqual(a, b, isEqual, meta);
            }
            if (aTag === MAP_TAG) {
                return areMapsEqual(a, b, isEqual, meta);
            }
            if (aTag === SET_TAG) {
                return areSetsEqual(a, b, isEqual, meta);
            }
            // If a simple object tag, then we can prioritize a simple object comparison because
            // it is likely a custom class. If an arguments tag, it should be treated as a standard
            // object.
            if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
                // The exception for value comparison is `Promise`-like contracts. These should be
                // treated the same as standard `Promise` objects, which means strict equality.
                return isPromiseLike(a) || isPromiseLike(b) ? false : areObjectsEqual(a, b, isEqual, meta);
            }
            // As the penultimate fallback, check if the values passed are primitive wrappers. This
            // is very rare in modern JS, which is why it is deprioritized compared to all other object
            // types.
            if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
                return sameValueZeroEqual(a.valueOf(), b.valueOf());
            }
            // If not matching any tags that require a specific type of comparison, then we hard-code false because
            // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:
            //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only
            //     comparison that can be made.
            //   - For types that can be introspected, but rarely have requirements to be compared
            //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common
            //     use-cases (may be included in a future release, if requested enough).
            //   - For types that can be introspected but do not have an objective definition of what
            //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.
            // In all cases, these decisions should be reevaluated based on changes to the language and
            // common development practices.
            return false;
        }
        return comparator;
    }
    /**
   * Whether the arrays are equal in value.
   */ function areArraysEqual(a, b, isEqual, meta) {
        var index = a.length;
        if (b.length !== index) {
            return false;
        }
        // Decrementing `while` showed faster results than either incrementing or
        // decrementing `for` loop and than an incrementing `while` loop. Declarative
        // methods like `some` / `every` were not used to avoid incurring the garbage
        // cost of anonymous callbacks.
        while(index-- > 0){
            if (!isEqual(a[index], b[index], index, index, a, b, meta)) {
                return false;
            }
        }
        return true;
    }
    /**
   * Whether the arrays are equal in value, including circular references.
   */ var areArraysEqualCircular = createIsCircular(areArraysEqual);
    /**
   * Whether the dates passed are equal in value.
   *
   * @NOTE
   * This is a standalone function instead of done inline in the comparator
   * to allow for overrides.
   */ function areDatesEqual(a, b) {
        return sameValueZeroEqual(a.valueOf(), b.valueOf());
    }
    /**
   * Whether the `Map`s are equal in value.
   */ function areMapsEqual(a, b, isEqual, meta) {
        var isValueEqual = a.size === b.size;
        if (!isValueEqual) {
            return false;
        }
        if (!a.size) {
            return true;
        }
        // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and
        // the inability to control the performance of the resulting code. It also avoids excessive
        // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,
        // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the
        // equality checks themselves.
        var matchedIndices = {};
        var indexA = 0;
        a.forEach(function(aValue, aKey) {
            if (!isValueEqual) {
                return;
            }
            var hasMatch = false;
            var matchIndexB = 0;
            b.forEach(function(bValue, bKey) {
                if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) && isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
                    matchedIndices[matchIndexB] = true;
                }
                matchIndexB++;
            });
            indexA++;
            isValueEqual = hasMatch;
        });
        return isValueEqual;
    }
    /**
   * Whether the `Map`s are equal in value, including circular references.
   */ var areMapsEqualCircular = createIsCircular(areMapsEqual);
    var OWNER = '_owner';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
   * Whether the objects are equal in value.
   */ function areObjectsEqual(a, b, isEqual, meta) {
        var keysA = Object.keys(a);
        var index = keysA.length;
        if (Object.keys(b).length !== index) {
            return false;
        }
        var key;
        // Decrementing `while` showed faster results than either incrementing or
        // decrementing `for` loop and than an incrementing `while` loop. Declarative
        // methods like `some` / `every` were not used to avoid incurring the garbage
        // cost of anonymous callbacks.
        while(index-- > 0){
            key = keysA[index];
            if (key === OWNER) {
                var reactElementA = !!a.$$typeof;
                var reactElementB = !!b.$$typeof;
                if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
                    return false;
                }
            }
            if (!hasOwnProperty.call(b, key) || !isEqual(a[key], b[key], key, key, a, b, meta)) {
                return false;
            }
        }
        return true;
    }
    /**
   * Whether the objects are equal in value, including circular references.
   */ var areObjectsEqualCircular = createIsCircular(areObjectsEqual);
    /**
   * Whether the regexps passed are equal in value.
   *
   * @NOTE
   * This is a standalone function instead of done inline in the comparator
   * to allow for overrides. An example of this would be supporting a
   * pre-ES2015 environment where the `flags` property is not available.
   */ function areRegExpsEqual(a, b) {
        return a.source === b.source && a.flags === b.flags;
    }
    /**
   * Whether the `Set`s are equal in value.
   */ function areSetsEqual(a, b, isEqual, meta) {
        var isValueEqual = a.size === b.size;
        if (!isValueEqual) {
            return false;
        }
        if (!a.size) {
            return true;
        }
        // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and
        // the inability to control the performance of the resulting code. It also avoids excessive
        // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,
        // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the
        // equality checks themselves.
        var matchedIndices = {};
        a.forEach(function(aValue, aKey) {
            if (!isValueEqual) {
                return;
            }
            var hasMatch = false;
            var matchIndex = 0;
            b.forEach(function(bValue, bKey) {
                if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
                    matchedIndices[matchIndex] = true;
                }
                matchIndex++;
            });
            isValueEqual = hasMatch;
        });
        return isValueEqual;
    }
    /**
   * Whether the `Set`s are equal in value, including circular references.
   */ var areSetsEqualCircular = createIsCircular(areSetsEqual);
    var DEFAULT_CONFIG = Object.freeze({
        areArraysEqual: areArraysEqual,
        areDatesEqual: areDatesEqual,
        areMapsEqual: areMapsEqual,
        areObjectsEqual: areObjectsEqual,
        areRegExpsEqual: areRegExpsEqual,
        areSetsEqual: areSetsEqual,
        createIsNestedEqual: createDefaultIsNestedEqual
    });
    var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
        areArraysEqual: areArraysEqualCircular,
        areDatesEqual: areDatesEqual,
        areMapsEqual: areMapsEqualCircular,
        areObjectsEqual: areObjectsEqualCircular,
        areRegExpsEqual: areRegExpsEqual,
        areSetsEqual: areSetsEqualCircular,
        createIsNestedEqual: createDefaultIsNestedEqual
    });
    var isDeepEqual = createComparator(DEFAULT_CONFIG);
    /**
   * Whether the items passed are deeply-equal in value.
   */ function deepEqual(a, b) {
        return isDeepEqual(a, b, undefined);
    }
    var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, {
        createIsNestedEqual: function() {
            return sameValueZeroEqual;
        }
    }));
    /**
   * Whether the items passed are shallowly-equal in value.
   */ function shallowEqual(a, b) {
        return isShallowEqual(a, b, undefined);
    }
    var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);
    /**
   * Whether the items passed are deeply-equal in value, including circular references.
   */ function circularDeepEqual(a, b) {
        return isCircularDeepEqual(a, b, new WeakMap());
    }
    var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {
        createIsNestedEqual: function() {
            return sameValueZeroEqual;
        }
    }));
    /**
   * Whether the items passed are shallowly-equal in value, including circular references.
   */ function circularShallowEqual(a, b) {
        return isCircularShallowEqual(a, b, new WeakMap());
    }
    /**
   * Create a custom equality comparison method.
   *
   * This can be done to create very targeted comparisons in extreme hot-path scenarios
   * where the standard methods are not performant enough, but can also be used to provide
   * support for legacy environments that do not support expected features like
   * `RegExp.prototype.flags` out of the box.
   */ function createCustomEqual(getComparatorOptions) {
        return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));
    }
    /**
   * Create a custom equality comparison method that handles circular references. This is very
   * similar to `createCustomEqual`, with the only difference being that `meta` expects to be
   * populated with a `WeakMap`-like contract.
   *
   * This can be done to create very targeted comparisons in extreme hot-path scenarios
   * where the standard methods are not performant enough, but can also be used to provide
   * support for legacy environments that do not support expected features like
   * `WeakMap` out of the box.
   */ function createCustomCircularEqual(getComparatorOptions) {
        var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));
        return function(a, b, meta) {
            if (meta === void 0) {
                meta = new WeakMap();
            }
            return comparator(a, b, meta);
        };
    }
    exports1.circularDeepEqual = circularDeepEqual;
    exports1.circularShallowEqual = circularShallowEqual;
    exports1.createCustomCircularEqual = createCustomCircularEqual;
    exports1.createCustomEqual = createCustomEqual;
    exports1.deepEqual = deepEqual;
    exports1.sameValueZeroEqual = sameValueZeroEqual;
    exports1.shallowEqual = shallowEqual;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
}); //# sourceMappingURL=fast-equals.js.map
}),
"[project]/node_modules/react-grid-layout/dist/chunk-XM2M6TC6.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GridItem",
    ()=>GridItem,
    "GridLayout",
    ()=>GridLayout,
    "ResponsiveGridLayout",
    ()=>ResponsiveGridLayout
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/chunk-XYPIYYYQ.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/chunk-AWM66AWF.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$draggable$2f$build$2f$cjs$2f$cjs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-draggable/build/cjs/cjs.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$resizable$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-resizable/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-equals/dist/fast-equals.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function GridItem(props) {
    const { children, cols, containerWidth, margin, containerPadding, rowHeight, maxRows, isDraggable, isResizable, isBounded, static: isStatic, useCSSTransforms = true, usePercentages = false, transformScale = 1, positionStrategy, dragThreshold = 0, droppingPosition, className = "", style, handle = "", cancel = "", x, y, w, h, minW = 1, maxW = Infinity, minH = 1, maxH = Infinity, i, resizeHandles, resizeHandle, constraints = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultConstraints"], layoutItem, layout = [], onDragStart: onDragStartProp, onDrag: onDragProp, onDragStop: onDragStopProp, onResizeStart: onResizeStartProp, onResize: onResizeProp, onResizeStop: onResizeStopProp } = props;
    const [dragging, setDragging] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    const [resizing, setResizing] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    const elementRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const dragPositionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        left: 0,
        top: 0
    });
    const resizePositionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        top: 0,
        left: 0,
        width: 0,
        height: 0
    });
    const prevDroppingPositionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
    const layoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(layout);
    layoutRef.current = layout;
    const onDragStartRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const onDragRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const dragPendingRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const initialDragClientRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        x: 0,
        y: 0
    });
    const thresholdExceededRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const positionParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridItem.useMemo[positionParams]": ()=>({
                cols,
                containerPadding,
                containerWidth,
                margin,
                maxRows,
                rowHeight
            })
    }["GridItem.useMemo[positionParams]"], [
        cols,
        containerPadding,
        containerWidth,
        margin,
        maxRows,
        rowHeight
    ]);
    const constraintContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridItem.useMemo[constraintContext]": ()=>({
                cols,
                maxRows,
                containerWidth,
                containerHeight: 0,
                // Auto-height grids don't have a fixed container height
                rowHeight,
                margin,
                // Use empty layout here - the actual layout will be accessed via layoutRef when needed
                // This prevents the context from changing when layout changes, avoiding callback recreation
                layout: []
            })
    }["GridItem.useMemo[constraintContext]"], [
        cols,
        maxRows,
        containerWidth,
        rowHeight,
        margin
    ]);
    const getConstraintContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[getConstraintContext]": ()=>({
                ...constraintContext,
                layout: layoutRef.current
            })
    }["GridItem.useCallback[getConstraintContext]"], [
        constraintContext
    ]);
    const effectiveLayoutItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridItem.useMemo[effectiveLayoutItem]": ()=>layoutItem ?? {
                i,
                x,
                y,
                w,
                h,
                minW,
                maxW,
                minH,
                maxH
            }
    }["GridItem.useMemo[effectiveLayoutItem]"], [
        layoutItem,
        i,
        x,
        y,
        w,
        h,
        minW,
        maxW,
        minH,
        maxH
    ]);
    const createStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[createStyle]": (pos2)=>{
            if (positionStrategy?.calcStyle) {
                return positionStrategy.calcStyle(pos2);
            }
            if (useCSSTransforms) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setTransform"])(pos2);
            }
            const styleObj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setTopLeft"])(pos2);
            if (usePercentages) {
                return {
                    ...styleObj,
                    left: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["perc"])(pos2.left / containerWidth),
                    width: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["perc"])(pos2.width / containerWidth)
                };
            }
            return styleObj;
        }
    }["GridItem.useCallback[createStyle]"], [
        positionStrategy,
        useCSSTransforms,
        usePercentages,
        containerWidth
    ]);
    const onDragStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[onDragStart]": (e, { node })=>{
            if (!onDragStartProp) return;
            const { offsetParent } = node;
            if (!offsetParent) return;
            const parentRect = offsetParent.getBoundingClientRect();
            const clientRect = node.getBoundingClientRect();
            const cLeft = clientRect.left / transformScale;
            const pLeft = parentRect.left / transformScale;
            const cTop = clientRect.top / transformScale;
            const pTop = parentRect.top / transformScale;
            let newPosition;
            if (positionStrategy?.calcDragPosition) {
                const mouseEvent = e;
                newPosition = positionStrategy.calcDragPosition(mouseEvent.clientX, mouseEvent.clientY, mouseEvent.clientX - clientRect.left, mouseEvent.clientY - clientRect.top);
            } else {
                newPosition = {
                    left: cLeft - pLeft + offsetParent.scrollLeft,
                    top: cTop - pTop + offsetParent.scrollTop
                };
            }
            dragPositionRef.current = newPosition;
            if (dragThreshold > 0) {
                const mouseEvent = e;
                initialDragClientRef.current = {
                    x: mouseEvent.clientX,
                    y: mouseEvent.clientY
                };
                dragPendingRef.current = true;
                thresholdExceededRef.current = false;
                setDragging(true);
                return;
            }
            setDragging(true);
            const rawPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcXYRaw"])(positionParams, newPosition.top, newPosition.left);
            const { x: newX, y: newY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPositionConstraints"])(constraints, effectiveLayoutItem, rawPos.x, rawPos.y, getConstraintContext());
            onDragStartProp(i, newX, newY, {
                e,
                node,
                newPosition
            });
        }
    }["GridItem.useCallback[onDragStart]"], [
        onDragStartProp,
        transformScale,
        positionParams,
        positionStrategy,
        dragThreshold,
        constraints,
        effectiveLayoutItem,
        getConstraintContext,
        i
    ]);
    const onDrag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[onDrag]": (e, { node, deltaX, deltaY })=>{
            if (!onDragProp || !dragging) return;
            const mouseEvent = e;
            if (dragPendingRef.current && !thresholdExceededRef.current) {
                const dx = mouseEvent.clientX - initialDragClientRef.current.x;
                const dy = mouseEvent.clientY - initialDragClientRef.current.y;
                const distance = Math.hypot(dx, dy);
                if (distance < dragThreshold) {
                    return;
                }
                thresholdExceededRef.current = true;
                dragPendingRef.current = false;
                if (onDragStartProp) {
                    const rawPos2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcXYRaw"])(positionParams, dragPositionRef.current.top, dragPositionRef.current.left);
                    const { x: startX, y: startY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPositionConstraints"])(constraints, effectiveLayoutItem, rawPos2.x, rawPos2.y, getConstraintContext());
                    onDragStartProp(i, startX, startY, {
                        e,
                        node,
                        newPosition: dragPositionRef.current
                    });
                }
            }
            let top = dragPositionRef.current.top + deltaY;
            let left = dragPositionRef.current.left + deltaX;
            if (isBounded) {
                const { offsetParent } = node;
                if (offsetParent) {
                    const bottomBoundary = offsetParent.clientHeight - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemWHPx"])(h, rowHeight, margin[1]);
                    top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(top, 0, bottomBoundary);
                    const colWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridColWidth"])(positionParams);
                    const rightBoundary = containerWidth - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemWHPx"])(w, colWidth, margin[0]);
                    left = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(left, 0, rightBoundary);
                }
            }
            const newPosition = {
                top,
                left
            };
            dragPositionRef.current = newPosition;
            const rawPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcXYRaw"])(positionParams, top, left);
            const { x: newX, y: newY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPositionConstraints"])(constraints, effectiveLayoutItem, rawPos.x, rawPos.y, getConstraintContext());
            onDragProp(i, newX, newY, {
                e,
                node,
                newPosition
            });
        }
    }["GridItem.useCallback[onDrag]"], [
        onDragProp,
        onDragStartProp,
        dragging,
        dragThreshold,
        isBounded,
        h,
        rowHeight,
        margin,
        positionParams,
        containerWidth,
        w,
        i,
        constraints,
        effectiveLayoutItem,
        getConstraintContext
    ]);
    const onDragStop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[onDragStop]": (e, { node })=>{
            if (!onDragStopProp || !dragging) return;
            const wasPending = dragPendingRef.current;
            dragPendingRef.current = false;
            thresholdExceededRef.current = false;
            initialDragClientRef.current = {
                x: 0,
                y: 0
            };
            if (wasPending) {
                setDragging(false);
                dragPositionRef.current = {
                    left: 0,
                    top: 0
                };
                return;
            }
            const { left, top } = dragPositionRef.current;
            const newPosition = {
                top,
                left
            };
            setDragging(false);
            dragPositionRef.current = {
                left: 0,
                top: 0
            };
            const rawPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcXYRaw"])(positionParams, top, left);
            const { x: newX, y: newY } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPositionConstraints"])(constraints, effectiveLayoutItem, rawPos.x, rawPos.y, getConstraintContext());
            onDragStopProp(i, newX, newY, {
                e,
                node,
                newPosition
            });
        }
    }["GridItem.useCallback[onDragStop]"], [
        onDragStopProp,
        dragging,
        positionParams,
        constraints,
        effectiveLayoutItem,
        getConstraintContext,
        i
    ]);
    onDragStartRef.current = onDragStart;
    onDragRef.current = onDrag;
    const onResizeHandler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[onResizeHandler]": (e, { node, size, handle: resizeHandle2 }, position, handlerName)=>{
            const handler = handlerName === "onResizeStart" ? onResizeStartProp : handlerName === "onResize" ? onResizeProp : onResizeStopProp;
            if (!handler) return;
            let updatedSize;
            if (node) {
                updatedSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resizeItemInDirection"])(resizeHandle2, position, size, containerWidth);
            } else {
                updatedSize = {
                    ...size,
                    top: position.top,
                    left: position.left
                };
            }
            resizePositionRef.current = updatedSize;
            const rawSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcWHRaw"])(positionParams, updatedSize.width, updatedSize.height);
            const { w: newW, h: newH } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applySizeConstraints"])(constraints, effectiveLayoutItem, rawSize.w, rawSize.h, resizeHandle2, getConstraintContext());
            handler(i, newW, newH, {
                e: e.nativeEvent,
                node,
                size: updatedSize,
                handle: resizeHandle2
            });
        }
    }["GridItem.useCallback[onResizeHandler]"], [
        onResizeStartProp,
        onResizeProp,
        onResizeStopProp,
        containerWidth,
        positionParams,
        i,
        constraints,
        effectiveLayoutItem,
        getConstraintContext
    ]);
    const handleResizeStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[handleResizeStart]": (e, data)=>{
            setResizing(true);
            const pos2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemPosition"])(positionParams, x, y, w, h);
            const typedData = {
                ...data,
                handle: data.handle
            };
            onResizeHandler(e, typedData, pos2, "onResizeStart");
        }
    }["GridItem.useCallback[handleResizeStart]"], [
        onResizeHandler,
        positionParams,
        x,
        y,
        w,
        h
    ]);
    const handleResize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[handleResize]": (e, data)=>{
            const pos2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemPosition"])(positionParams, x, y, w, h);
            const typedData = {
                ...data,
                handle: data.handle
            };
            onResizeHandler(e, typedData, pos2, "onResize");
        }
    }["GridItem.useCallback[handleResize]"], [
        onResizeHandler,
        positionParams,
        x,
        y,
        w,
        h
    ]);
    const handleResizeStop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridItem.useCallback[handleResizeStop]": (e, data)=>{
            setResizing(false);
            resizePositionRef.current = {
                top: 0,
                left: 0,
                width: 0,
                height: 0
            };
            const pos2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemPosition"])(positionParams, x, y, w, h);
            const typedData = {
                ...data,
                handle: data.handle
            };
            onResizeHandler(e, typedData, pos2, "onResizeStop");
        }
    }["GridItem.useCallback[handleResizeStop]"], [
        onResizeHandler,
        positionParams,
        x,
        y,
        w,
        h
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "GridItem.useEffect": ()=>{
            if (!droppingPosition) return;
            const node = elementRef.current;
            if (!node) return;
            const prevDroppingPosition = prevDroppingPositionRef.current || {
                left: 0,
                top: 0
            };
            const shouldDrag = dragging && (droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top);
            if (!dragging) {
                const fakeData = {
                    node,
                    deltaX: droppingPosition.left,
                    deltaY: droppingPosition.top,
                    lastX: 0,
                    lastY: 0,
                    x: droppingPosition.left,
                    y: droppingPosition.top
                };
                onDragStartRef.current?.(droppingPosition.e, fakeData);
            } else if (shouldDrag) {
                const deltaX = droppingPosition.left - dragPositionRef.current.left;
                const deltaY = droppingPosition.top - dragPositionRef.current.top;
                const fakeData = {
                    node,
                    deltaX,
                    deltaY,
                    lastX: dragPositionRef.current.left,
                    lastY: dragPositionRef.current.top,
                    x: droppingPosition.left,
                    y: droppingPosition.top
                };
                onDragRef.current?.(droppingPosition.e, fakeData);
            }
            prevDroppingPositionRef.current = droppingPosition;
        }
    }["GridItem.useEffect"], [
        droppingPosition,
        dragging,
        i
    ]);
    const pos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemPosition"])(positionParams, x, y, w, h, dragging ? dragPositionRef.current : null, resizing ? resizePositionRef.current : null);
    const child = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.only(children);
    const minGridUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemPosition"])(positionParams, 0, 0, 1, 1);
    const minConstraints = [
        minGridUnit.width,
        minGridUnit.height
    ];
    const maxConstraints = [
        Infinity,
        Infinity
    ];
    const childProps = child.props;
    const childClassName = childProps["className"];
    const childStyle = childProps["style"];
    let newChild = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cloneElement(child, {
        ref: elementRef,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("react-grid-item", childClassName, className, {
            static: isStatic,
            resizing,
            "react-draggable": isDraggable,
            "react-draggable-dragging": dragging,
            dropping: Boolean(droppingPosition),
            cssTransforms: useCSSTransforms
        }),
        style: {
            ...style,
            ...childStyle,
            ...createStyle(pos)
        }
    });
    const resizableHandle = resizeHandle;
    newChild = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$resizable$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Resizable"], {
        draggableOpts: {
            disabled: !isResizable
        },
        className: isResizable ? void 0 : "react-resizable-hide",
        width: pos.width,
        height: pos.height,
        minConstraints,
        maxConstraints,
        onResizeStart: handleResizeStart,
        onResize: handleResize,
        onResizeStop: handleResizeStop,
        transformScale,
        resizeHandles,
        handle: resizableHandle,
        children: newChild
    });
    newChild = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$draggable$2f$build$2f$cjs$2f$cjs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DraggableCore"], {
        disabled: !isDraggable,
        onStart: onDragStart,
        onDrag,
        onStop: onDragStop,
        handle,
        cancel: ".react-resizable-handle" + (cancel ? "," + cancel : ""),
        scale: transformScale,
        nodeRef: elementRef,
        children: newChild
    });
    return newChild;
}
var noop = ()=>{};
var layoutClassName = "react-grid-layout";
var isFirefox = false;
try {
    isFirefox = /firefox/i.test(navigator.userAgent);
} catch  {}
function childrenEqual(a, b) {
    const aArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.toArray(a);
    const bArr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.toArray(b);
    if (aArr.length !== bArr.length) return false;
    for(let i = 0; i < aArr.length; i++){
        const aChild = aArr[i];
        const bChild = bArr[i];
        if (aChild?.key !== bChild?.key) return false;
    }
    return true;
}
function synchronizeLayoutWithChildren(initialLayout, children, cols, compactor) {
    const layout = [];
    const childKeys = /* @__PURE__ */ new Set();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.forEach(children, (child)=>{
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(child) || child.key === null) return;
        const key = String(child.key);
        childKeys.add(key);
        const existingItem = initialLayout.find((l)=>l.i === key);
        if (existingItem) {
            layout.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayoutItem"])(existingItem));
        } else {
            const childProps = child.props;
            const dataGrid = childProps["data-grid"];
            if (dataGrid) {
                layout.push({
                    i: key,
                    x: dataGrid.x ?? 0,
                    y: dataGrid.y ?? 0,
                    w: dataGrid.w ?? 1,
                    h: dataGrid.h ?? 1,
                    minW: dataGrid.minW,
                    maxW: dataGrid.maxW,
                    minH: dataGrid.minH,
                    maxH: dataGrid.maxH,
                    static: dataGrid.static,
                    isDraggable: dataGrid.isDraggable,
                    isResizable: dataGrid.isResizable,
                    resizeHandles: dataGrid.resizeHandles,
                    isBounded: dataGrid.isBounded
                });
            } else {
                layout.push({
                    i: key,
                    x: 0,
                    y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bottom"])(layout),
                    w: 1,
                    h: 1
                });
            }
        }
    });
    const corrected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["correctBounds"])(layout, {
        cols
    });
    return compactor.compact(corrected, cols);
}
function GridLayout(props) {
    const { // Required
    children, width, // Composable config interfaces
    gridConfig: gridConfigProp, dragConfig: dragConfigProp, resizeConfig: resizeConfigProp, dropConfig: dropConfigProp, positionStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultPositionStrategy"], compactor: compactorProp, constraints = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultConstraints"], // Layout data
    layout: propsLayout = [], droppingItem: droppingItemProp, // Container props
    autoSize = true, className = "", style = {}, innerRef, // Callbacks
    onLayoutChange = noop, onDragStart: onDragStartProp = noop, onDrag: onDragProp = noop, onDragStop: onDragStopProp = noop, onResizeStart: onResizeStartProp = noop, onResize: onResizeProp = noop, onResizeStop: onResizeStopProp = noop, onDrop: onDropProp = noop, onDropDragOver: onDropDragOverProp = noop } = props;
    const gridConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[gridConfig]": ()=>({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultGridConfig"],
                ...gridConfigProp
            })
    }["GridLayout.useMemo[gridConfig]"], [
        gridConfigProp
    ]);
    const dragConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[dragConfig]": ()=>({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultDragConfig"],
                ...dragConfigProp
            })
    }["GridLayout.useMemo[dragConfig]"], [
        dragConfigProp
    ]);
    const resizeConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[resizeConfig]": ()=>({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultResizeConfig"],
                ...resizeConfigProp
            })
    }["GridLayout.useMemo[resizeConfig]"], [
        resizeConfigProp
    ]);
    const dropConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[dropConfig]": ()=>({
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultDropConfig"],
                ...dropConfigProp
            })
    }["GridLayout.useMemo[dropConfig]"], [
        dropConfigProp
    ]);
    const { cols, rowHeight, maxRows, margin, containerPadding } = gridConfig;
    const { enabled: isDraggable, bounded: isBounded, handle: draggableHandle, cancel: draggableCancel, threshold: dragThreshold } = dragConfig;
    const { enabled: isResizable, handles: resizeHandles, handleComponent: resizeHandle } = resizeConfig;
    const { enabled: isDroppable, defaultItem: defaultDropItem, onDragOver: dropConfigOnDragOver } = dropConfig;
    const compactor = compactorProp ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCompactor"])("vertical");
    const compactType = compactor.type;
    const allowOverlap = compactor.allowOverlap;
    const preventCollision = compactor.preventCollision ?? false;
    const droppingItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[droppingItem]": ()=>droppingItemProp ?? {
                i: "__dropping-elem__",
                ...defaultDropItem
            }
    }["GridLayout.useMemo[droppingItem]"], [
        droppingItemProp,
        defaultDropItem
    ]);
    const useCSSTransforms = positionStrategy.type === "transform";
    const transformScale = positionStrategy.scale;
    const effectiveContainerPadding = containerPadding ?? margin;
    const [mounted, setMounted] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    const [layout, setLayout] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "GridLayout.useState": ()=>synchronizeLayoutWithChildren(propsLayout, children, cols, compactor)
    }["GridLayout.useState"]);
    const [activeDrag, setActiveDrag] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    const [resizing, setResizing] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
    const [droppingDOMNode, setDroppingDOMNode] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    const [droppingPosition, setDroppingPosition] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])();
    const oldDragItemRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const oldResizeItemRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const oldLayoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const dragEnterCounterRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(0);
    const prevLayoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(layout);
    const prevPropsLayoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(propsLayout);
    const prevChildrenRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(children);
    const prevCompactTypeRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(compactType);
    const layoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(layout);
    layoutRef.current = layout;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "GridLayout.useEffect": ()=>{
            setMounted(true);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(layout, propsLayout)) {
                onLayoutChange(layout);
            }
        }
    }["GridLayout.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "GridLayout.useEffect": ()=>{
            if (activeDrag) return;
            if (droppingDOMNode) return;
            const layoutChanged = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(propsLayout, prevPropsLayoutRef.current);
            const childrenChanged = !childrenEqual(children, prevChildrenRef.current);
            const compactTypeChanged = compactType !== prevCompactTypeRef.current;
            if (layoutChanged || childrenChanged || compactTypeChanged) {
                const baseLayout = layoutChanged ? propsLayout : layout;
                const newLayout = synchronizeLayoutWithChildren(baseLayout, children, cols, compactor);
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(newLayout, layout)) {
                    setLayout(newLayout);
                }
            }
            prevPropsLayoutRef.current = propsLayout;
            prevChildrenRef.current = children;
            prevCompactTypeRef.current = compactType;
        }
    }["GridLayout.useEffect"], [
        propsLayout,
        children,
        cols,
        compactType,
        compactor,
        activeDrag,
        droppingDOMNode,
        layout
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "GridLayout.useEffect": ()=>{
            if (!activeDrag && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(layout, prevLayoutRef.current)) {
                prevLayoutRef.current = layout;
                const publicLayout = layout.filter({
                    "GridLayout.useEffect.publicLayout": (l)=>l.i !== droppingItem.i
                }["GridLayout.useEffect.publicLayout"]);
                onLayoutChange(publicLayout);
            }
        }
    }["GridLayout.useEffect"], [
        layout,
        activeDrag,
        onLayoutChange,
        droppingItem.i
    ]);
    const containerHeight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "GridLayout.useMemo[containerHeight]": ()=>{
            if (!autoSize) return void 0;
            const nbRow = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bottom"])(layout);
            const containerPaddingY = effectiveContainerPadding[1];
            return nbRow * rowHeight + (nbRow - 1) * margin[1] + containerPaddingY * 2 + "px";
        }
    }["GridLayout.useMemo[containerHeight]"], [
        autoSize,
        layout,
        rowHeight,
        margin,
        effectiveContainerPadding
    ]);
    const onDragStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onDragStart]": (i, _x, _y, data)=>{
            const currentLayout = layoutRef.current;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(currentLayout, i);
            if (!l) return;
            const placeholder = {
                w: l.w,
                h: l.h,
                x: l.x,
                y: l.y,
                i
            };
            oldDragItemRef.current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayoutItem"])(l);
            oldLayoutRef.current = currentLayout;
            setActiveDrag(placeholder);
            onDragStartProp(currentLayout, l, l, null, data.e, data.node);
        }
    }["GridLayout.useCallback[onDragStart]"], [
        onDragStartProp
    ]);
    const onDrag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onDrag]": (i, x, y, data)=>{
            const currentLayout = layoutRef.current;
            const oldDragItem = oldDragItemRef.current;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(currentLayout, i);
            if (!l) return;
            const placeholder = {
                w: l.w,
                h: l.h,
                x: l.x,
                y: l.y,
                i
            };
            const newLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["moveElement"])(currentLayout, l, x, y, true, preventCollision, compactType, cols, allowOverlap);
            onDragProp(newLayout, oldDragItem, l, placeholder, data.e, data.node);
            setLayout(compactor.compact(newLayout, cols));
            setActiveDrag(placeholder);
        }
    }["GridLayout.useCallback[onDrag]"], [
        preventCollision,
        compactType,
        cols,
        allowOverlap,
        compactor,
        onDragProp
    ]);
    const onDragStop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onDragStop]": (i, x, y, data)=>{
            if (!activeDrag) return;
            const currentLayout = layoutRef.current;
            const oldDragItem = oldDragItemRef.current;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(currentLayout, i);
            if (!l) return;
            const newLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["moveElement"])(currentLayout, l, x, y, true, preventCollision, compactType, cols, allowOverlap);
            const finalLayout = compactor.compact(newLayout, cols);
            onDragStopProp(finalLayout, oldDragItem, l, null, data.e, data.node);
            const oldLayout = oldLayoutRef.current;
            oldDragItemRef.current = null;
            oldLayoutRef.current = null;
            setActiveDrag(null);
            setLayout(finalLayout);
            if (oldLayout && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(oldLayout, finalLayout)) {
                onLayoutChange(finalLayout);
            }
        }
    }["GridLayout.useCallback[onDragStop]"], [
        activeDrag,
        preventCollision,
        compactType,
        cols,
        allowOverlap,
        compactor,
        onDragStopProp,
        onLayoutChange
    ]);
    const onResizeStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onResizeStart]": (i, _w, _h, data)=>{
            const currentLayout = layoutRef.current;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(currentLayout, i);
            if (!l) return;
            oldResizeItemRef.current = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayoutItem"])(l);
            oldLayoutRef.current = currentLayout;
            setResizing(true);
            onResizeStartProp(currentLayout, l, l, null, data.e, data.node);
        }
    }["GridLayout.useCallback[onResizeStart]"], [
        onResizeStartProp
    ]);
    const onResize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onResize]": (i, w, h, data)=>{
            const currentLayout = layoutRef.current;
            const oldResizeItem = oldResizeItemRef.current;
            const { handle } = data;
            let shouldMoveItem = false;
            let newX;
            let newY;
            const [newLayout, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withLayoutItem"])(currentLayout, i, {
                "GridLayout.useCallback[onResize]": (item)=>{
                    newX = item.x;
                    newY = item.y;
                    if ([
                        "sw",
                        "w",
                        "nw",
                        "n",
                        "ne"
                    ].includes(handle)) {
                        if ([
                            "sw",
                            "nw",
                            "w"
                        ].includes(handle)) {
                            newX = item.x + (item.w - w);
                            w = item.x !== newX && newX < 0 ? item.w : w;
                            newX = newX < 0 ? 0 : newX;
                        }
                        if ([
                            "ne",
                            "n",
                            "nw"
                        ].includes(handle)) {
                            newY = item.y + (item.h - h);
                            h = item.y !== newY && newY < 0 ? item.h : h;
                            newY = newY < 0 ? 0 : newY;
                        }
                        shouldMoveItem = true;
                    }
                    if (preventCollision && !allowOverlap) {
                        const collisions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAllCollisions"])(currentLayout, {
                            ...item,
                            w,
                            h,
                            x: newX ?? item.x,
                            y: newY ?? item.y
                        }).filter({
                            "GridLayout.useCallback[onResize].collisions": (layoutItem)=>layoutItem.i !== item.i
                        }["GridLayout.useCallback[onResize].collisions"]);
                        if (collisions.length > 0) {
                            newY = item.y;
                            h = item.h;
                            newX = item.x;
                            w = item.w;
                            shouldMoveItem = false;
                        }
                    }
                    item.w = w;
                    item.h = h;
                    return item;
                }
            }["GridLayout.useCallback[onResize]"]);
            if (!l) return;
            let finalLayout = newLayout;
            if (shouldMoveItem && newX !== void 0 && newY !== void 0) {
                finalLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["moveElement"])(newLayout, l, newX, newY, true, preventCollision, compactType, cols, allowOverlap);
            }
            const placeholder = {
                w: l.w,
                h: l.h,
                x: l.x,
                y: l.y,
                i,
                static: true
            };
            onResizeProp(finalLayout, oldResizeItem, l, placeholder, data.e, data.node);
            setLayout(compactor.compact(finalLayout, cols));
            setActiveDrag(placeholder);
        }
    }["GridLayout.useCallback[onResize]"], [
        preventCollision,
        compactType,
        cols,
        allowOverlap,
        compactor,
        onResizeProp
    ]);
    const onResizeStop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[onResizeStop]": (i, _w, _h, data)=>{
            const currentLayout = layoutRef.current;
            const oldResizeItem = oldResizeItemRef.current;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(currentLayout, i);
            const finalLayout = compactor.compact(currentLayout, cols);
            onResizeStopProp(finalLayout, oldResizeItem, l ?? null, null, data.e, data.node);
            const oldLayout = oldLayoutRef.current;
            oldResizeItemRef.current = null;
            oldLayoutRef.current = null;
            setActiveDrag(null);
            setResizing(false);
            setLayout(finalLayout);
            if (oldLayout && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(oldLayout, finalLayout)) {
                onLayoutChange(finalLayout);
            }
        }
    }["GridLayout.useCallback[onResizeStop]"], [
        cols,
        compactor,
        onResizeStopProp,
        onLayoutChange
    ]);
    const removeDroppingPlaceholder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[removeDroppingPlaceholder]": ()=>{
            const currentLayout = layoutRef.current;
            const hasDroppingItem = currentLayout.some({
                "GridLayout.useCallback[removeDroppingPlaceholder].hasDroppingItem": (l)=>l.i === droppingItem.i
            }["GridLayout.useCallback[removeDroppingPlaceholder].hasDroppingItem"]);
            if (!hasDroppingItem) {
                setDroppingDOMNode(null);
                setActiveDrag(null);
                setDroppingPosition(void 0);
                return;
            }
            const newLayout = compactor.compact(currentLayout.filter({
                "GridLayout.useCallback[removeDroppingPlaceholder].newLayout": (l)=>l.i !== droppingItem.i
            }["GridLayout.useCallback[removeDroppingPlaceholder].newLayout"]), cols);
            setLayout(newLayout);
            setDroppingDOMNode(null);
            setActiveDrag(null);
            setDroppingPosition(void 0);
        }
    }["GridLayout.useCallback[removeDroppingPlaceholder]"], [
        droppingItem.i,
        cols,
        compactor
    ]);
    const handleDragOver = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[handleDragOver]": (e)=>{
            e.preventDefault();
            e.stopPropagation();
            if (isFirefox && !e.nativeEvent.target?.classList.contains(layoutClassName)) {
                return false;
            }
            const rawResult = dropConfigOnDragOver ? dropConfigOnDragOver(e.nativeEvent) : onDropDragOverProp(e);
            if (rawResult === false) {
                if (droppingDOMNode) {
                    removeDroppingPlaceholder();
                }
                return false;
            }
            const { dragOffsetX = 0, dragOffsetY = 0, ...onDragOverResult } = rawResult ?? {};
            const finalDroppingItem = {
                ...droppingItem,
                ...onDragOverResult
            };
            const gridRect = e.currentTarget.getBoundingClientRect();
            const positionParams = {
                cols,
                margin,
                maxRows,
                rowHeight,
                containerWidth: width,
                containerPadding: effectiveContainerPadding
            };
            const actualColWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridColWidth"])(positionParams);
            const itemPixelWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemWHPx"])(finalDroppingItem.w, actualColWidth, margin[0]);
            const itemPixelHeight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcGridItemWHPx"])(finalDroppingItem.h, rowHeight, margin[1]);
            const itemCenterOffsetX = itemPixelWidth / 2;
            const itemCenterOffsetY = itemPixelHeight / 2;
            const rawGridX = e.clientX - gridRect.left + dragOffsetX - itemCenterOffsetX;
            const rawGridY = e.clientY - gridRect.top + dragOffsetY - itemCenterOffsetY;
            const clampedGridX = Math.max(0, rawGridX);
            const clampedGridY = Math.max(0, rawGridY);
            const newDroppingPosition = {
                left: clampedGridX / transformScale,
                top: clampedGridY / transformScale,
                e: e.nativeEvent
            };
            if (!droppingDOMNode) {
                const calculatedPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcXY"])(positionParams, clampedGridY, clampedGridX, finalDroppingItem.w, finalDroppingItem.h);
                setDroppingDOMNode(/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {}, finalDroppingItem.i));
                setDroppingPosition(newDroppingPosition);
                setLayout([
                    ...layoutRef.current,
                    {
                        ...finalDroppingItem,
                        x: calculatedPosition.x,
                        y: calculatedPosition.y,
                        static: false,
                        isDraggable: true
                    }
                ]);
            } else if (droppingPosition) {
                const shouldUpdate = droppingPosition.left !== newDroppingPosition.left || droppingPosition.top !== newDroppingPosition.top;
                if (shouldUpdate) {
                    setDroppingPosition(newDroppingPosition);
                }
            }
        }
    }["GridLayout.useCallback[handleDragOver]"], [
        droppingDOMNode,
        droppingPosition,
        droppingItem,
        dropConfigOnDragOver,
        onDropDragOverProp,
        removeDroppingPlaceholder,
        transformScale,
        cols,
        margin,
        maxRows,
        rowHeight,
        width,
        effectiveContainerPadding
    ]);
    const handleDragLeave = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[handleDragLeave]": (e)=>{
            e.preventDefault();
            e.stopPropagation();
            dragEnterCounterRef.current--;
            if (dragEnterCounterRef.current < 0) {
                dragEnterCounterRef.current = 0;
            }
            if (dragEnterCounterRef.current === 0) {
                removeDroppingPlaceholder();
            }
        }
    }["GridLayout.useCallback[handleDragLeave]"], [
        removeDroppingPlaceholder
    ]);
    const handleDragEnter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[handleDragEnter]": (e)=>{
            e.preventDefault();
            e.stopPropagation();
            dragEnterCounterRef.current++;
        }
    }["GridLayout.useCallback[handleDragEnter]"], []);
    const handleDrop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[handleDrop]": (e)=>{
            e.preventDefault();
            e.stopPropagation();
            const currentLayout = layoutRef.current;
            const item = currentLayout.find({
                "GridLayout.useCallback[handleDrop].item": (l)=>l.i === droppingItem.i
            }["GridLayout.useCallback[handleDrop].item"]);
            dragEnterCounterRef.current = 0;
            removeDroppingPlaceholder();
            onDropProp(currentLayout, item, e.nativeEvent);
        }
    }["GridLayout.useCallback[handleDrop]"], [
        droppingItem.i,
        removeDroppingPlaceholder,
        onDropProp
    ]);
    const processGridItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "GridLayout.useCallback[processGridItem]": (child, isDroppingItem)=>{
            if (!child || !child.key) return null;
            const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLayoutItem"])(layout, String(child.key));
            if (!l) return null;
            const draggable = typeof l.isDraggable === "boolean" ? l.isDraggable : !l.static && isDraggable;
            const resizable = typeof l.isResizable === "boolean" ? l.isResizable : !l.static && isResizable;
            const resizeHandlesOptions = l.resizeHandles || [
                ...resizeHandles
            ];
            const bounded = draggable && isBounded && l.isBounded !== false;
            const resizeHandleElement = resizeHandle;
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GridItem, {
                containerWidth: width,
                cols,
                margin,
                containerPadding: effectiveContainerPadding,
                maxRows,
                rowHeight,
                cancel: draggableCancel,
                handle: draggableHandle,
                onDragStart,
                onDrag,
                onDragStop,
                onResizeStart,
                onResize,
                onResizeStop,
                isDraggable: draggable,
                isResizable: resizable,
                isBounded: bounded,
                useCSSTransforms: useCSSTransforms && mounted,
                usePercentages: !mounted,
                transformScale,
                positionStrategy,
                dragThreshold,
                w: l.w,
                h: l.h,
                x: l.x,
                y: l.y,
                i: l.i,
                minH: l.minH,
                minW: l.minW,
                maxH: l.maxH,
                maxW: l.maxW,
                static: l.static,
                droppingPosition: isDroppingItem ? droppingPosition : void 0,
                resizeHandles: resizeHandlesOptions,
                resizeHandle: resizeHandleElement,
                constraints,
                layoutItem: l,
                layout,
                children: child
            }, l.i);
        }
    }["GridLayout.useCallback[processGridItem]"], [
        layout,
        width,
        cols,
        margin,
        effectiveContainerPadding,
        maxRows,
        rowHeight,
        draggableCancel,
        draggableHandle,
        onDragStart,
        onDrag,
        onDragStop,
        onResizeStart,
        onResize,
        onResizeStop,
        isDraggable,
        isResizable,
        isBounded,
        useCSSTransforms,
        mounted,
        transformScale,
        positionStrategy,
        dragThreshold,
        droppingPosition,
        resizeHandles,
        resizeHandle,
        constraints
    ]);
    const renderPlaceholder = ()=>{
        if (!activeDrag) return null;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GridItem, {
            w: activeDrag.w,
            h: activeDrag.h,
            x: activeDrag.x,
            y: activeDrag.y,
            i: activeDrag.i,
            className: `react-grid-placeholder ${resizing ? "placeholder-resizing" : ""}`,
            containerWidth: width,
            cols,
            margin,
            containerPadding: effectiveContainerPadding,
            maxRows,
            rowHeight,
            isDraggable: false,
            isResizable: false,
            isBounded: false,
            useCSSTransforms,
            transformScale,
            constraints,
            layout,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {})
        });
    };
    const mergedClassName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(layoutClassName, className);
    const mergedStyle = {
        height: containerHeight,
        ...style
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("div", {
        ref: innerRef,
        className: mergedClassName,
        style: mergedStyle,
        onDrop: isDroppable ? handleDrop : void 0,
        onDragLeave: isDroppable ? handleDragLeave : void 0,
        onDragEnter: isDroppable ? handleDragEnter : void 0,
        onDragOver: isDroppable ? handleDragOver : void 0,
        children: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.map(children, (child)=>{
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(child)) return null;
                return processGridItem(child);
            }),
            isDroppable && droppingDOMNode && processGridItem(droppingDOMNode, true),
            renderPlaceholder()
        ]
    });
}
var DEFAULT_BREAKPOINTS = {
    lg: 1200,
    md: 996,
    sm: 768,
    xs: 480,
    xxs: 0
};
var DEFAULT_COLS = {
    lg: 12,
    md: 10,
    sm: 6,
    xs: 4,
    xxs: 2
};
var noop2 = ()=>{};
function synchronizeLayoutWithChildren2(initialLayout, children, cols, compactor) {
    const layout = [];
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Children.forEach(children, (child)=>{
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(child) || child.key === null) return;
        const key = String(child.key);
        const existingItem = initialLayout.find((l)=>l.i === key);
        if (existingItem) {
            layout.push({
                ...existingItem,
                i: key
            });
        } else {
            const childProps = child.props;
            const dataGrid = childProps["data-grid"];
            if (dataGrid) {
                layout.push({
                    i: key,
                    x: dataGrid.x ?? 0,
                    y: dataGrid.y ?? 0,
                    w: dataGrid.w ?? 1,
                    h: dataGrid.h ?? 1,
                    minW: dataGrid.minW,
                    maxW: dataGrid.maxW,
                    minH: dataGrid.minH,
                    maxH: dataGrid.maxH,
                    static: dataGrid.static,
                    isDraggable: dataGrid.isDraggable,
                    isResizable: dataGrid.isResizable,
                    resizeHandles: dataGrid.resizeHandles,
                    isBounded: dataGrid.isBounded
                });
            } else {
                layout.push({
                    i: key,
                    x: 0,
                    y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bottom"])(layout),
                    w: 1,
                    h: 1
                });
            }
        }
    });
    const corrected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["correctBounds"])(layout, {
        cols
    });
    return compactor.compact(corrected, cols);
}
function ResponsiveGridLayout(props) {
    const { children, width, breakpoint: propBreakpoint, breakpoints = DEFAULT_BREAKPOINTS, cols: colsConfig = DEFAULT_COLS, layouts: propsLayouts = {}, rowHeight = 150, maxRows = Infinity, margin: propMargin = [
        10,
        10
    ], containerPadding: propContainerPadding = null, compactor: compactorProp, onBreakpointChange = noop2, onLayoutChange = noop2, onWidthChange = noop2, ...restProps } = props;
    const compactor = compactorProp ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCompactor"])("vertical");
    const compactType = compactor.type;
    const allowOverlap = compactor.allowOverlap;
    const initialBreakpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[initialBreakpoint]": ()=>{
            return propBreakpoint ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBreakpointFromWidth"])(breakpoints, width);
        }
    }["ResponsiveGridLayout.useMemo[initialBreakpoint]"], []);
    const initialCols = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[initialCols]": ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getColsFromBreakpoint"])(initialBreakpoint, colsConfig);
        }
    }["ResponsiveGridLayout.useMemo[initialCols]"], [
        initialBreakpoint,
        colsConfig
    ]);
    const initialLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[initialLayout]": ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOrGenerateResponsiveLayout"])(propsLayouts, breakpoints, initialBreakpoint, initialBreakpoint, initialCols, compactType);
        }
    }["ResponsiveGridLayout.useMemo[initialLayout]"], []);
    const [breakpoint, setBreakpoint] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initialBreakpoint);
    const [cols, setCols] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initialCols);
    const [layout, setLayout] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initialLayout);
    const [layouts, setLayouts] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(propsLayouts);
    const prevWidthRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(width);
    const prevBreakpointRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(propBreakpoint);
    const prevBreakpointsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(breakpoints);
    const prevColsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(colsConfig);
    const prevLayoutsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(propsLayouts);
    const prevCompactTypeRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(compactType);
    const layoutsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(layouts);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ResponsiveGridLayout.useEffect": ()=>{
            layoutsRef.current = layouts;
        }
    }["ResponsiveGridLayout.useEffect"], [
        layouts
    ]);
    const derivedLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[derivedLayout]": ()=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(propsLayouts, prevLayoutsRef.current)) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOrGenerateResponsiveLayout"])(propsLayouts, breakpoints, breakpoint, breakpoint, cols, compactor);
            }
            return null;
        }
    }["ResponsiveGridLayout.useMemo[derivedLayout]"], [
        propsLayouts,
        breakpoints,
        breakpoint,
        cols,
        compactor
    ]);
    const effectiveLayout = derivedLayout ?? layout;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ResponsiveGridLayout.useEffect": ()=>{
            if (derivedLayout !== null) {
                setLayout(derivedLayout);
                setLayouts(propsLayouts);
                layoutsRef.current = propsLayouts;
                prevLayoutsRef.current = propsLayouts;
            }
        }
    }["ResponsiveGridLayout.useEffect"], [
        derivedLayout,
        propsLayouts
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ResponsiveGridLayout.useEffect": ()=>{
            if (compactType !== prevCompactTypeRef.current) {
                const newLayout = compactor.compact((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(effectiveLayout), cols);
                const newLayouts = {
                    ...layoutsRef.current,
                    [breakpoint]: newLayout
                };
                setLayout(newLayout);
                setLayouts(newLayouts);
                layoutsRef.current = newLayouts;
                onLayoutChange(newLayout, newLayouts);
                prevCompactTypeRef.current = compactType;
            }
        }
    }["ResponsiveGridLayout.useEffect"], [
        compactType,
        compactor,
        effectiveLayout,
        cols,
        allowOverlap,
        breakpoint,
        onLayoutChange
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ResponsiveGridLayout.useEffect": ()=>{
            const widthChanged = width !== prevWidthRef.current;
            const breakpointPropChanged = propBreakpoint !== prevBreakpointRef.current;
            const breakpointsChanged = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(breakpoints, prevBreakpointsRef.current);
            const colsChanged = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$equals$2f$dist$2f$fast$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(colsConfig, prevColsRef.current);
            if (widthChanged || breakpointPropChanged || breakpointsChanged || colsChanged) {
                const newBreakpoint = propBreakpoint ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBreakpointFromWidth"])(breakpoints, width);
                const newCols = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getColsFromBreakpoint"])(newBreakpoint, colsConfig);
                const lastBreakpoint = breakpoint;
                if (lastBreakpoint !== newBreakpoint || breakpointsChanged || colsChanged) {
                    const newLayouts = {
                        ...layoutsRef.current
                    };
                    if (!newLayouts[lastBreakpoint]) {
                        newLayouts[lastBreakpoint] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$AWM66AWF$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneLayout"])(layout);
                    }
                    let newLayout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findOrGenerateResponsiveLayout"])(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactor);
                    newLayout = synchronizeLayoutWithChildren2(newLayout, children, newCols, compactor);
                    newLayouts[newBreakpoint] = newLayout;
                    setBreakpoint(newBreakpoint);
                    setCols(newCols);
                    setLayout(newLayout);
                    setLayouts(newLayouts);
                    layoutsRef.current = newLayouts;
                    onBreakpointChange(newBreakpoint, newCols);
                    onLayoutChange(newLayout, newLayouts);
                }
                const currentMargin2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIndentationValue"])(propMargin, newBreakpoint);
                const currentPadding = propContainerPadding ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIndentationValue"])(propContainerPadding, newBreakpoint) : null;
                onWidthChange(width, currentMargin2, newCols, currentPadding);
                prevWidthRef.current = width;
                prevBreakpointRef.current = propBreakpoint;
                prevBreakpointsRef.current = breakpoints;
                prevColsRef.current = colsConfig;
            }
        }
    }["ResponsiveGridLayout.useEffect"], [
        width,
        propBreakpoint,
        breakpoints,
        colsConfig,
        breakpoint,
        cols,
        layout,
        children,
        compactor,
        compactType,
        allowOverlap,
        propMargin,
        propContainerPadding,
        onBreakpointChange,
        onLayoutChange,
        onWidthChange
    ]);
    const handleLayoutChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "ResponsiveGridLayout.useCallback[handleLayoutChange]": (newLayout)=>{
            const currentLayouts = layoutsRef.current;
            const newLayouts = {
                ...currentLayouts,
                [breakpoint]: newLayout
            };
            setLayout(newLayout);
            setLayouts(newLayouts);
            layoutsRef.current = newLayouts;
            onLayoutChange(newLayout, newLayouts);
        }
    }["ResponsiveGridLayout.useCallback[handleLayoutChange]"], [
        breakpoint,
        onLayoutChange
    ]);
    const currentMargin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[currentMargin]": ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIndentationValue"])(propMargin, breakpoint);
        }
    }["ResponsiveGridLayout.useMemo[currentMargin]"], [
        propMargin,
        breakpoint
    ]);
    const currentContainerPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[currentContainerPadding]": ()=>{
            if (propContainerPadding === null) return null;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIndentationValue"])(propContainerPadding, breakpoint);
        }
    }["ResponsiveGridLayout.useMemo[currentContainerPadding]"], [
        propContainerPadding,
        breakpoint
    ]);
    const gridConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "ResponsiveGridLayout.useMemo[gridConfig]": ()=>({
                cols,
                rowHeight,
                maxRows,
                margin: currentMargin,
                containerPadding: currentContainerPadding
            })
    }["ResponsiveGridLayout.useMemo[gridConfig]"], [
        cols,
        rowHeight,
        maxRows,
        currentMargin,
        currentContainerPadding
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GridLayout, {
        ...restProps,
        width,
        gridConfig,
        compactor,
        onLayoutChange: handleLayoutChange,
        layout: effectiveLayout,
        children
    });
}
;
 //# sourceMappingURL=chunk-XM2M6TC6.mjs.map
 //# sourceMappingURL=chunk-XM2M6TC6.mjs.map
}),
"[project]/node_modules/react-grid-layout/dist/legacy.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReactGridLayout",
    ()=>ReactGridLayout,
    "Responsive",
    ()=>ResponsiveReactGridLayout_default,
    "ResponsiveReactGridLayout",
    ()=>ResponsiveReactGridLayout,
    "WidthProvider",
    ()=>WidthProvider,
    "default",
    ()=>ReactGridLayout_default
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XM2M6TC6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/chunk-XM2M6TC6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/chunk-XYPIYYYQ.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
function ReactGridLayout(props) {
    const { // Required
    children, width, // Grid measurement
    cols = 12, rowHeight = 150, maxRows = Infinity, margin = [
        10,
        10
    ], containerPadding = null, // Layout data
    layout, droppingItem, // Compaction
    compactType: compactTypeProp, preventCollision = false, allowOverlap = false, verticalCompact, // Drag behavior
    isDraggable = true, isBounded = false, draggableHandle, draggableCancel, // Resize behavior
    isResizable = true, resizeHandles = [
        "se"
    ], resizeHandle, // Drop behavior
    isDroppable = false, // Position
    useCSSTransforms = true, transformScale = 1, // Container props
    autoSize, className, style, innerRef, // Callbacks
    onLayoutChange, onDragStart, onDrag, onDragStop, onResizeStart, onResize, onResizeStop, onDrop, onDropDragOver } = props;
    let compactType = compactTypeProp === void 0 ? "vertical" : compactTypeProp;
    if (verticalCompact === false) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.warn('`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.');
        }
        compactType = null;
    }
    const gridConfig = {
        cols,
        rowHeight,
        maxRows,
        margin,
        containerPadding
    };
    const dragConfig = {
        enabled: isDraggable,
        bounded: isBounded,
        handle: draggableHandle,
        cancel: draggableCancel,
        // Set threshold to 0 for backwards compatibility with v1 API
        // v2 API defaults to 3px threshold (fixes #1341, #1401)
        threshold: 0
    };
    const resizeConfig = {
        enabled: isResizable,
        handles: resizeHandles,
        handleComponent: resizeHandle
    };
    const dropConfig = {
        enabled: isDroppable
    };
    let positionStrategy;
    if (!useCSSTransforms) {
        positionStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["absoluteStrategy"];
    } else if (transformScale !== 1) {
        positionStrategy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createScaledStrategy"])(transformScale);
    } else {
        positionStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformStrategy"];
    }
    const compactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCompactor"])(compactType, allowOverlap, preventCollision);
    const constraints = isBounded ? [
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultConstraints"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containerBounds"]
    ] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultConstraints"];
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XM2M6TC6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GridLayout"], {
        width,
        gridConfig,
        dragConfig,
        resizeConfig,
        dropConfig,
        positionStrategy,
        compactor,
        constraints,
        layout,
        droppingItem,
        autoSize,
        className,
        style,
        innerRef,
        onLayoutChange,
        onDragStart,
        onDrag,
        onDragStop,
        onResizeStart,
        onResize,
        onResizeStop,
        onDrop,
        onDropDragOver,
        children
    });
}
ReactGridLayout.displayName = "ReactGridLayout";
var ReactGridLayout_default = ReactGridLayout;
function ResponsiveReactGridLayout(props) {
    const { // Required
    children, width, // Responsive-specific
    breakpoint, breakpoints, cols, layouts, onBreakpointChange, onLayoutChange, onWidthChange, // Grid measurement
    rowHeight, maxRows, margin, containerPadding, // Layout data
    droppingItem, // Compaction
    compactType: compactTypeProp, preventCollision = false, allowOverlap = false, verticalCompact, // Drag behavior
    isDraggable = true, isBounded = false, draggableHandle, draggableCancel, // Resize behavior
    isResizable = true, resizeHandles = [
        "se"
    ], resizeHandle, // Drop behavior
    isDroppable = false, // Position
    useCSSTransforms = true, transformScale = 1, // Container props
    autoSize, className, style, innerRef, // Callbacks
    onDragStart, onDrag, onDragStop, onResizeStart, onResize, onResizeStop, onDrop, onDropDragOver } = props;
    let compactType = compactTypeProp === void 0 ? "vertical" : compactTypeProp;
    if (verticalCompact === false) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.warn('`verticalCompact` on <ResponsiveReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.');
        }
        compactType = null;
    }
    const dragConfig = {
        enabled: isDraggable,
        bounded: isBounded,
        handle: draggableHandle,
        cancel: draggableCancel
    };
    const resizeConfig = {
        enabled: isResizable,
        handles: resizeHandles,
        handleComponent: resizeHandle
    };
    const dropConfig = {
        enabled: isDroppable
    };
    let positionStrategy;
    if (!useCSSTransforms) {
        positionStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["absoluteStrategy"];
    } else if (transformScale !== 1) {
        positionStrategy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createScaledStrategy"])(transformScale);
    } else {
        positionStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformStrategy"];
    }
    const compactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XYPIYYYQ$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCompactor"])(compactType, allowOverlap, preventCollision);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$grid$2d$layout$2f$dist$2f$chunk$2d$XM2M6TC6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResponsiveGridLayout"], {
        width,
        breakpoint,
        breakpoints,
        cols,
        layouts,
        rowHeight,
        maxRows,
        margin,
        containerPadding,
        compactor,
        dragConfig,
        resizeConfig,
        dropConfig,
        positionStrategy,
        droppingItem,
        autoSize,
        className,
        style,
        innerRef,
        onBreakpointChange,
        onLayoutChange,
        onWidthChange,
        onDragStart,
        onDrag,
        onDragStop,
        onResizeStart,
        onResize,
        onResizeStop,
        onDrop,
        onDropDragOver,
        children
    });
}
ResponsiveReactGridLayout.displayName = "ResponsiveReactGridLayout";
var ResponsiveReactGridLayout_default = ResponsiveReactGridLayout;
var layoutClassName = "react-grid-layout";
function WidthProvider(ComposedComponent) {
    function WidthProviderWrapper(props) {
        const { measureBeforeMount = false, className, style, ...rest } = props;
        const [width, setWidth] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(1280);
        const [mounted, setMounted] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
        const elementRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
        const resizeObserverRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "WidthProvider.WidthProviderWrapper.useEffect": ()=>{
                setMounted(true);
            }
        }["WidthProvider.WidthProviderWrapper.useEffect"], []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "WidthProvider.WidthProviderWrapper.useEffect": ()=>{
                const node = elementRef.current;
                if (!(node instanceof HTMLElement)) return;
                const observer = new ResizeObserver({
                    "WidthProvider.WidthProviderWrapper.useEffect": (entries)=>{
                        if (entries[0]) {
                            const newWidth = entries[0].contentRect.width;
                            setWidth(newWidth);
                        }
                    }
                }["WidthProvider.WidthProviderWrapper.useEffect"]);
                observer.observe(node);
                resizeObserverRef.current = observer;
                return ({
                    "WidthProvider.WidthProviderWrapper.useEffect": ()=>{
                        observer.unobserve(node);
                        observer.disconnect();
                    }
                })["WidthProvider.WidthProviderWrapper.useEffect"];
            }
        }["WidthProvider.WidthProviderWrapper.useEffect"], [
            mounted
        ]);
        if (measureBeforeMount && !mounted) {
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(className, layoutClassName),
                style,
                ref: elementRef
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ComposedComponent, {
            innerRef: elementRef,
            className,
            style,
            ...rest,
            width
        });
    }
    WidthProviderWrapper.displayName = `WidthProvider(${ComposedComponent.displayName || ComposedComponent.name || "Component"})`;
    return WidthProviderWrapper;
}
;
 //# sourceMappingURL=legacy.mjs.map
 //# sourceMappingURL=legacy.mjs.map
}),
"[project]/node_modules/react-grid-layout/dist/legacy.mjs [app-client] (ecmascript, next/dynamic entry)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/react-grid-layout/dist/legacy.mjs [app-client] (ecmascript)"));
}),
]);

//# sourceMappingURL=node_modules_d64707c7._.js.map